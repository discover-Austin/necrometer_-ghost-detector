{"ast":null,"code":"/*jslint browser */\n\nimport { Capacitor, registerPlugin } from \"@capacitor/core\";\nimport { Filesystem } from \"@capacitor/filesystem\";\nconst BlobWriter = registerPlugin(\"BlobWriter\");\nfunction array_buffer_to_base64(buffer) {\n  return window.btoa(Array.from(new Uint8Array(buffer)).map(function (byte) {\n    return String.fromCharCode(byte);\n  }).join(\"\"));\n}\nfunction write_file_via_indexeddb({\n  path,\n  directory,\n  blob,\n  recursive\n}) {\n  // Firstly, create the file entry in the database. This populates a bunch of\n  // properties on the entry, such as mtime, ctime and type, and also gives the\n  // Filesystem plugin a chance to initialize its database.\n\n  return Filesystem.writeFile({\n    directory,\n    path,\n    recursive,\n    data: \"\"\n  }).then(function () {\n    // Now reach into IndexedDB and assign 'blob' to the file entry.\n\n    return new Promise(function (resolve, reject) {\n      function fail(event) {\n        reject(event.target.error);\n      }\n      const connection = window.indexedDB.open(\"Disc\");\n      connection.onerror = fail;\n      connection.onsuccess = function () {\n        const db = connection.result;\n        const transaction = db.transaction(\"FileStorage\", \"readwrite\");\n        transaction.onerror = fail;\n        const store = transaction.objectStore(\"FileStorage\");\n        const name = `/${directory}/${path.replace(/^\\//, \"\")}`;\n        const load = store.get(name);\n        load.onsuccess = function () {\n          load.result.size = blob.size;\n          load.result.content = blob;\n          const put = store.put(load.result);\n          put.onsuccess = function () {\n            resolve(undefined);\n          };\n        };\n      };\n    });\n  });\n}\nfunction write_file_via_bridge({\n  path,\n  directory,\n  blob,\n  recursive\n}) {\n  // Firstly, create or truncate the file.\n\n  return Filesystem.writeFile({\n    directory,\n    path,\n    recursive,\n    data: \"\"\n  }).then(function consume_blob() {\n    // Now write the file incrementally so that we do not exhaust our memory in\n    // attempting to Base64 encode the entire Blob at once.\n\n    if (blob.size === 0) {\n      return Promise.resolve();\n    }\n\n    // By choosing a chunk size which is a multiple of 3, we avoid a bug in\n    // Filesystem.appendFile, only on the web platform, which corrupts files by\n    // inserting Base64 padding characters within the file. See\n    // https://github.com/ionic-team/capacitor-plugins/issues/649.\n\n    const chunk_size = 3 * 128 * 1024;\n    const chunk_blob = blob.slice(0, chunk_size);\n    blob = blob.slice(chunk_size);\n\n    // Read the Blob as an ArrayBuffer, then append it to the file on disk.\n\n    return new Response(chunk_blob).arrayBuffer().then(function append_chunk_to_file(buffer) {\n      return Filesystem.appendFile({\n        directory,\n        path,\n        data: array_buffer_to_base64(buffer)\n      });\n    }).then(consume_blob);\n  });\n}\nfunction write_blob(options) {\n  const {\n    path,\n    directory,\n    blob,\n    fast_mode = false,\n    recursive,\n    on_fallback\n  } = options;\n  if (!blob || !Number.isSafeInteger(blob.size) || typeof blob.type !== \"string\") {\n    return Promise.reject(new Error(\"Not a Blob.\"));\n  }\n  if (Capacitor.getPlatform() === \"web\") {\n    return fast_mode ? write_file_via_indexeddb(options) : write_file_via_bridge(options);\n  }\n  return Promise.all([BlobWriter.get_config(), Filesystem.getUri({\n    path,\n    directory\n  })]).then(function ([config, file_info]) {\n    const absolute_path = file_info.uri.replace(\"file://\", \"\");\n\n    // The built-in CapacitorHttp plugin can be configured to monkey patch the\n    // global 'fetch' function, but that forces 'blob' over the bridge which is\n    // what we're trying to avoid. We attempt to subvert the monkey patching.\n\n    const real_fetch = window.CapacitorWebFetch || window.fetch;\n    return real_fetch(config.base_url + absolute_path + (recursive ? \"?recursive=true\" : \"\"), {\n      headers: {\n        authorization: config.auth_token\n      },\n      method: \"put\",\n      body: blob\n    }).then(function (response) {\n      if (response.status !== 204) {\n        throw new Error(\"Bad HTTP status: \" + response.status);\n      }\n\n      // Producing a file URI is deprecated. In the next major version, the returned\n      // Promise should resolve to undefined.\n\n      return file_info.uri;\n    });\n  }).catch(function on_fail(error) {\n    if (on_fallback !== undefined) {\n      on_fallback(error);\n    }\n    return write_file_via_bridge(options);\n  });\n}\nexport default Object.freeze(write_blob);","map":{"version":3,"names":["Capacitor","registerPlugin","Filesystem","BlobWriter","array_buffer_to_base64","buffer","window","btoa","Array","from","Uint8Array","map","byte","String","fromCharCode","join","write_file_via_indexeddb","path","directory","blob","recursive","writeFile","data","then","Promise","resolve","reject","fail","event","target","error","connection","indexedDB","open","onerror","onsuccess","db","result","transaction","store","objectStore","name","replace","load","get","size","content","put","undefined","write_file_via_bridge","consume_blob","chunk_size","chunk_blob","slice","Response","arrayBuffer","append_chunk_to_file","appendFile","write_blob","options","fast_mode","on_fallback","Number","isSafeInteger","type","Error","getPlatform","all","get_config","getUri","config","file_info","absolute_path","uri","real_fetch","CapacitorWebFetch","fetch","base_url","headers","authorization","auth_token","method","body","response","status","catch","on_fail","Object","freeze"],"sources":["C:/Users/grand/necrometer_-ghost-detector-1/node_modules/capacitor-blob-writer/blob_writer.js"],"sourcesContent":["/*jslint browser */\n\nimport {Capacitor, registerPlugin} from \"@capacitor/core\";\nimport {Filesystem} from \"@capacitor/filesystem\";\n\nconst BlobWriter = registerPlugin(\"BlobWriter\");\n\nfunction array_buffer_to_base64(buffer) {\n    return window.btoa(\n        Array.from(new Uint8Array(buffer)).map(function (byte) {\n            return String.fromCharCode(byte);\n        }).join(\"\")\n    );\n}\n\nfunction write_file_via_indexeddb({\n    path,\n    directory,\n    blob,\n    recursive\n}) {\n\n// Firstly, create the file entry in the database. This populates a bunch of\n// properties on the entry, such as mtime, ctime and type, and also gives the\n// Filesystem plugin a chance to initialize its database.\n\n    return Filesystem.writeFile({\n        directory,\n        path,\n        recursive,\n        data: \"\"\n    }).then(function () {\n\n// Now reach into IndexedDB and assign 'blob' to the file entry.\n\n        return new Promise(function (resolve, reject) {\n            function fail(event) {\n                reject(event.target.error);\n            }\n            const connection = window.indexedDB.open(\"Disc\");\n            connection.onerror = fail;\n            connection.onsuccess = function () {\n                const db = connection.result;\n                const transaction = db.transaction(\"FileStorage\", \"readwrite\");\n                transaction.onerror = fail;\n                const store = transaction.objectStore(\"FileStorage\");\n                const name = `/${directory}/${path.replace(/^\\//, \"\")}`;\n                const load = store.get(name);\n                load.onsuccess = function () {\n                    load.result.size = blob.size;\n                    load.result.content = blob;\n                    const put = store.put(load.result);\n                    put.onsuccess = function () {\n                        resolve(undefined);\n                    };\n                };\n            };\n        });\n    });\n}\n\nfunction write_file_via_bridge({\n    path,\n    directory,\n    blob,\n    recursive\n}) {\n\n// Firstly, create or truncate the file.\n\n    return Filesystem.writeFile({\n        directory,\n        path,\n        recursive,\n        data: \"\"\n    }).then(function consume_blob() {\n\n// Now write the file incrementally so that we do not exhaust our memory in\n// attempting to Base64 encode the entire Blob at once.\n\n        if (blob.size === 0) {\n            return Promise.resolve();\n        }\n\n// By choosing a chunk size which is a multiple of 3, we avoid a bug in\n// Filesystem.appendFile, only on the web platform, which corrupts files by\n// inserting Base64 padding characters within the file. See\n// https://github.com/ionic-team/capacitor-plugins/issues/649.\n\n        const chunk_size = 3 * 128 * 1024;\n        const chunk_blob = blob.slice(0, chunk_size);\n        blob = blob.slice(chunk_size);\n\n// Read the Blob as an ArrayBuffer, then append it to the file on disk.\n\n        return new Response(\n            chunk_blob\n        ).arrayBuffer(\n        ).then(function append_chunk_to_file(buffer) {\n            return Filesystem.appendFile({\n                directory,\n                path,\n                data: array_buffer_to_base64(buffer)\n            });\n        }).then(\n            consume_blob\n        );\n    });\n}\n\nfunction write_blob(options) {\n    const {\n        path,\n        directory,\n        blob,\n        fast_mode = false,\n        recursive,\n        on_fallback\n    } = options;\n    if (\n        !blob\n        || !Number.isSafeInteger(blob.size)\n        || typeof blob.type !== \"string\"\n    ) {\n        return Promise.reject(new Error(\"Not a Blob.\"));\n    }\n    if (Capacitor.getPlatform() === \"web\") {\n        return (\n            fast_mode\n            ? write_file_via_indexeddb(options)\n            : write_file_via_bridge(options)\n        );\n    }\n    return Promise.all([\n        BlobWriter.get_config(),\n        Filesystem.getUri({path, directory})\n    ]).then(function ([config, file_info]) {\n        const absolute_path = file_info.uri.replace(\"file://\", \"\");\n\n// The built-in CapacitorHttp plugin can be configured to monkey patch the\n// global 'fetch' function, but that forces 'blob' over the bridge which is\n// what we're trying to avoid. We attempt to subvert the monkey patching.\n\n        const real_fetch = window.CapacitorWebFetch || window.fetch;\n        return real_fetch(\n            config.base_url + absolute_path + (\n                recursive\n                ? \"?recursive=true\"\n                : \"\"\n            ),\n            {\n                headers: {authorization: config.auth_token},\n                method: \"put\",\n                body: blob\n            }\n        ).then(function (response) {\n            if (response.status !== 204) {\n                throw new Error(\"Bad HTTP status: \" + response.status);\n            }\n\n// Producing a file URI is deprecated. In the next major version, the returned\n// Promise should resolve to undefined.\n\n            return file_info.uri;\n        });\n    }).catch(function on_fail(error) {\n        if (on_fallback !== undefined) {\n            on_fallback(error);\n        }\n        return write_file_via_bridge(options);\n    });\n}\n\nexport default Object.freeze(write_blob);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}