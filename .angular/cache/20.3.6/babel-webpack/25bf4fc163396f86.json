{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/grand/necrometer_-ghost-detector-1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Filesystem } from '@capacitor/filesystem';\nimport write_blob from 'capacitor-blob-writer';\nimport getBlobDuration from 'get-blob-duration';\nimport { RecordingStatus } from './definitions';\nimport { alreadyRecordingError, couldNotQueryPermissionStatusError, deviceCannotVoiceRecordError, emptyRecordingError, failedToFetchRecordingError, failedToRecordError, failureResponse, missingPermissionError, recordingHasNotStartedError, successResponse } from './predefined-web-responses';\n// these mime types will be checked one by one in order until one of them is found to be supported by the current browser\nconst POSSIBLE_MIME_TYPES = {\n  'audio/aac': '.aac',\n  'audio/webm;codecs=opus': '.ogg',\n  'audio/mp4': '.mp3',\n  'audio/webm': '.ogg',\n  'audio/ogg;codecs=opus': '.ogg'\n};\nconst neverResolvingPromise = () => new Promise(() => undefined);\nexport class VoiceRecorderImpl {\n  constructor() {\n    this.mediaRecorder = null;\n    this.chunks = [];\n    this.pendingResult = neverResolvingPromise();\n  }\n  static canDeviceVoiceRecord() {\n    return _asyncToGenerator(function* () {\n      var _a;\n      if (((_a = navigator === null || navigator === void 0 ? void 0 : navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia) == null || VoiceRecorderImpl.getSupportedMimeType() == null) {\n        return failureResponse();\n      } else {\n        return successResponse();\n      }\n    })();\n  }\n  startRecording(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.mediaRecorder != null) {\n        throw alreadyRecordingError();\n      }\n      const deviceCanRecord = yield VoiceRecorderImpl.canDeviceVoiceRecord();\n      if (!deviceCanRecord.value) {\n        throw deviceCannotVoiceRecordError();\n      }\n      const havingPermission = yield VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => successResponse());\n      if (!havingPermission.value) {\n        throw missingPermissionError();\n      }\n      return navigator.mediaDevices.getUserMedia({\n        audio: true\n      }).then(stream => _this.onSuccessfullyStartedRecording(stream, options)).catch(_this.onFailedToStartRecording.bind(_this));\n    })();\n  }\n  stopRecording() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.mediaRecorder == null) {\n        throw recordingHasNotStartedError();\n      }\n      try {\n        _this2.mediaRecorder.stop();\n        _this2.mediaRecorder.stream.getTracks().forEach(track => track.stop());\n        return _this2.pendingResult;\n      } catch (ignore) {\n        throw failedToFetchRecordingError();\n      } finally {\n        _this2.prepareInstanceForNextOperation();\n      }\n    })();\n  }\n  static hasAudioRecordingPermission() {\n    return _asyncToGenerator(function* () {\n      if (navigator.permissions.query == null) {\n        if (navigator.mediaDevices == null) {\n          return Promise.reject(couldNotQueryPermissionStatusError());\n        }\n        return navigator.mediaDevices.getUserMedia({\n          audio: true\n        }).then(() => successResponse()).catch(() => {\n          throw couldNotQueryPermissionStatusError();\n        });\n      }\n      return navigator.permissions.query({\n        name: 'microphone'\n      }).then(result => ({\n        value: result.state === 'granted'\n      })).catch(() => {\n        throw couldNotQueryPermissionStatusError();\n      });\n    })();\n  }\n  static requestAudioRecordingPermission() {\n    return _asyncToGenerator(function* () {\n      const havingPermission = yield VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => failureResponse());\n      if (havingPermission.value) {\n        return successResponse();\n      }\n      return navigator.mediaDevices.getUserMedia({\n        audio: true\n      }).then(() => successResponse()).catch(() => failureResponse());\n    })();\n  }\n  pauseRecording() {\n    if (this.mediaRecorder == null) {\n      throw recordingHasNotStartedError();\n    } else if (this.mediaRecorder.state === 'recording') {\n      this.mediaRecorder.pause();\n      return Promise.resolve(successResponse());\n    } else {\n      return Promise.resolve(failureResponse());\n    }\n  }\n  resumeRecording() {\n    if (this.mediaRecorder == null) {\n      throw recordingHasNotStartedError();\n    } else if (this.mediaRecorder.state === 'paused') {\n      this.mediaRecorder.resume();\n      return Promise.resolve(successResponse());\n    } else {\n      return Promise.resolve(failureResponse());\n    }\n  }\n  getCurrentStatus() {\n    if (this.mediaRecorder == null) {\n      return Promise.resolve({\n        status: RecordingStatus.NONE\n      });\n    } else if (this.mediaRecorder.state === 'recording') {\n      return Promise.resolve({\n        status: RecordingStatus.RECORDING\n      });\n    } else if (this.mediaRecorder.state === 'paused') {\n      return Promise.resolve({\n        status: RecordingStatus.PAUSED\n      });\n    } else {\n      return Promise.resolve({\n        status: RecordingStatus.NONE\n      });\n    }\n  }\n  static getSupportedMimeType() {\n    if ((MediaRecorder === null || MediaRecorder === void 0 ? void 0 : MediaRecorder.isTypeSupported) == null) return null;\n    const foundSupportedType = Object.keys(POSSIBLE_MIME_TYPES).find(type => MediaRecorder.isTypeSupported(type));\n    return foundSupportedType !== null && foundSupportedType !== void 0 ? foundSupportedType : null;\n  }\n  onSuccessfullyStartedRecording(stream, options) {\n    var _this3 = this;\n    this.pendingResult = new Promise((resolve, reject) => {\n      this.mediaRecorder = new MediaRecorder(stream);\n      this.mediaRecorder.onerror = () => {\n        this.prepareInstanceForNextOperation();\n        reject(failedToRecordError());\n      };\n      this.mediaRecorder.onstop = /*#__PURE__*/_asyncToGenerator(function* () {\n        var _a, _b, _c;\n        const mimeType = VoiceRecorderImpl.getSupportedMimeType();\n        if (mimeType == null) {\n          _this3.prepareInstanceForNextOperation();\n          reject(failedToFetchRecordingError());\n          return;\n        }\n        const blobVoiceRecording = new Blob(_this3.chunks, {\n          type: mimeType\n        });\n        if (blobVoiceRecording.size <= 0) {\n          _this3.prepareInstanceForNextOperation();\n          reject(emptyRecordingError());\n          return;\n        }\n        let uri;\n        let recordDataBase64;\n        if (options != null) {\n          const subDirectory = (_c = (_b = (_a = options.subDirectory) === null || _a === void 0 ? void 0 : _a.match(/^\\/?(.+[^/])\\/?$/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : '';\n          const path = `${subDirectory}/recording-${new Date().getTime()}${POSSIBLE_MIME_TYPES[mimeType]}`;\n          yield write_blob({\n            blob: blobVoiceRecording,\n            directory: options.directory,\n            fast_mode: true,\n            path,\n            recursive: true\n          });\n          ({\n            uri\n          } = yield Filesystem.getUri({\n            directory: options.directory,\n            path\n          }));\n        } else {\n          recordDataBase64 = yield VoiceRecorderImpl.blobToBase64(blobVoiceRecording);\n        }\n        const recordingDuration = yield getBlobDuration(blobVoiceRecording);\n        _this3.prepareInstanceForNextOperation();\n        resolve({\n          value: {\n            recordDataBase64,\n            mimeType,\n            msDuration: recordingDuration * 1000,\n            uri\n          }\n        });\n      });\n      this.mediaRecorder.ondataavailable = event => this.chunks.push(event.data);\n      this.mediaRecorder.start();\n    });\n    return successResponse();\n  }\n  onFailedToStartRecording() {\n    this.prepareInstanceForNextOperation();\n    throw failedToRecordError();\n  }\n  static blobToBase64(blob) {\n    return new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        const recordingResult = String(reader.result);\n        const splitResult = recordingResult.split('base64,');\n        const toResolve = splitResult.length > 1 ? splitResult[1] : recordingResult;\n        resolve(toResolve.trim());\n      };\n      reader.readAsDataURL(blob);\n    });\n  }\n  prepareInstanceForNextOperation() {\n    if (this.mediaRecorder != null && this.mediaRecorder.state === 'recording') {\n      try {\n        this.mediaRecorder.stop();\n      } catch (error) {\n        console.warn('While trying to stop a media recorder, an error was thrown', error);\n      }\n    }\n    this.pendingResult = neverResolvingPromise();\n    this.mediaRecorder = null;\n    this.chunks = [];\n  }\n}\n//# sourceMappingURL=VoiceRecorderImpl.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}