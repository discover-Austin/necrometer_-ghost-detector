{"ast":null,"code":"import { signal, effect, inject } from '@angular/core';\nimport { SensorService } from './sensor.service';\nimport * as i0 from \"@angular/core\";\nexport let DeviceStateService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class DeviceStateService {\n    constructor() {\n      this.sensorService = inject(SensorService);\n      this.emfReading = signal(0, ...(ngDevMode ? [{\n        debugName: \"emfReading\"\n      }] : []));\n      // Latest magnetometer magnitude (µT) reported by SensorService.magnetometer().\n      this.latestMagnetometer = 0;\n      // Exponentially smoothed baseline value to compensate for the Earth's magnetic field.\n      // The baseline will slowly adapt to environmental changes.\n      this.baselineMagnetometer = null;\n      // Start the update loop when the service is created\n      this.updateInterval = setInterval(() => this.updateEmf(), 100);\n      // React to changes in the magnetometer reading.  Update the latest\n      // magnitude and slowly adjust the baseline value to compensate for\n      // the Earth's magnetic field.  The baseline is updated using a very\n      // low smoothing factor (0.001) so that it adapts over minutes rather\n      // than seconds.  If baseline is not yet set, initialize it on first\n      // reading.\n      effect(() => {\n        const mag = this.sensorService.magnetometer();\n        if (mag != null) {\n          this.latestMagnetometer = mag;\n          if (this.baselineMagnetometer == null) {\n            this.baselineMagnetometer = mag;\n          } else {\n            // exponential smoothing: baseline += (mag - baseline) * alpha\n            const alpha = 0.001;\n            this.baselineMagnetometer = this.baselineMagnetometer + (mag - this.baselineMagnetometer) * alpha;\n          }\n        }\n      });\n    }\n    // Smoothly update the EMF reading towards a value derived from the\n    // magnetometer.  The target EMF value is the difference between the\n    // latest magnitude and the slowly-adapting baseline, scaled up to a\n    // 0–100 range to match the UI.  A small amount of noise is added\n    // proportional to the current target to mimic sensor jitter.\n    updateEmf() {\n      this.emfReading.update(current => {\n        // Ensure we have a baseline; if not, fall back to raw magnitude\n        const baseline = this.baselineMagnetometer != null ? this.baselineMagnetometer : 0;\n        let target = 0;\n        // compute difference; clamp to zero\n        const diff = this.latestMagnetometer - baseline;\n        if (diff > 0) {\n          // Scale difference to the UI range.  Earth's field ranges from\n          // ~25–65 µT, so differences of a few microteslas should produce\n          // modest readings.  Multiply by 3 and cap at 100.\n          target = Math.min(diff * 3, 100);\n        }\n        // move 10% towards the target each tick for smoothing\n        const smoothed = current + (target - current) * 0.1;\n        // noise scales with target: more agitation when target is high\n        const noise = (Math.random() - 0.5) * (0.3 + 0.05 * target);\n        const value = smoothed + noise;\n        return value < 0 ? 0 : value;\n      });\n    }\n    ngOnDestroy() {\n      if (this.updateInterval) {\n        clearInterval(this.updateInterval);\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function DeviceStateService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DeviceStateService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: DeviceStateService,\n      factory: DeviceStateService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return DeviceStateService;\n})();","map":{"version":3,"names":["signal","effect","inject","SensorService","DeviceStateService","_staticBlock","constructor","sensorService","emfReading","ngDevMode","debugName","latestMagnetometer","baselineMagnetometer","updateInterval","setInterval","updateEmf","mag","magnetometer","alpha","update","current","baseline","target","diff","Math","min","smoothed","noise","random","value","ngOnDestroy","clearInterval","_","factory","ɵfac","providedIn"],"sources":["C:\\Users\\grand\\necrometer_-ghost-detector-1\\src\\services\\device-state.service.ts"],"sourcesContent":["import { Injectable, signal, effect, OnDestroy, inject } from '@angular/core';\r\nimport { SensorService } from './sensor.service';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class DeviceStateService implements OnDestroy {\r\n  private sensorService = inject(SensorService);\r\n  emfReading = signal(0);\r\n\r\n  // Latest magnetometer magnitude (µT) reported by SensorService.magnetometer().\r\n  private latestMagnetometer = 0;\r\n  // Exponentially smoothed baseline value to compensate for the Earth's magnetic field.\r\n  // The baseline will slowly adapt to environmental changes.\r\n  private baselineMagnetometer: number | null = null;\r\n  private updateInterval: any;\r\n\r\n  constructor() {\r\n    // Start the update loop when the service is created\r\n    this.updateInterval = setInterval(() => this.updateEmf(), 100);\r\n\r\n    // React to changes in the magnetometer reading.  Update the latest\r\n    // magnitude and slowly adjust the baseline value to compensate for\r\n    // the Earth's magnetic field.  The baseline is updated using a very\r\n    // low smoothing factor (0.001) so that it adapts over minutes rather\r\n    // than seconds.  If baseline is not yet set, initialize it on first\r\n    // reading.\r\n    effect(() => {\r\n      const mag = this.sensorService.magnetometer();\r\n      if (mag != null) {\r\n        this.latestMagnetometer = mag;\r\n        if (this.baselineMagnetometer == null) {\r\n          this.baselineMagnetometer = mag;\r\n        } else {\r\n          // exponential smoothing: baseline += (mag - baseline) * alpha\r\n          const alpha = 0.001;\r\n          this.baselineMagnetometer =\r\n            this.baselineMagnetometer +\r\n            (mag - this.baselineMagnetometer) * alpha;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // Smoothly update the EMF reading towards a value derived from the\r\n  // magnetometer.  The target EMF value is the difference between the\r\n  // latest magnitude and the slowly-adapting baseline, scaled up to a\r\n  // 0–100 range to match the UI.  A small amount of noise is added\r\n  // proportional to the current target to mimic sensor jitter.\r\n  private updateEmf(): void {\r\n    this.emfReading.update(current => {\r\n      // Ensure we have a baseline; if not, fall back to raw magnitude\r\n      const baseline =\r\n        this.baselineMagnetometer != null ? this.baselineMagnetometer : 0;\r\n      let target = 0;\r\n      // compute difference; clamp to zero\r\n      const diff = this.latestMagnetometer - baseline;\r\n      if (diff > 0) {\r\n        // Scale difference to the UI range.  Earth's field ranges from\r\n        // ~25–65 µT, so differences of a few microteslas should produce\r\n        // modest readings.  Multiply by 3 and cap at 100.\r\n        target = Math.min(diff * 3, 100);\r\n      }\r\n      // move 10% towards the target each tick for smoothing\r\n      const smoothed = current + (target - current) * 0.1;\r\n      // noise scales with target: more agitation when target is high\r\n      const noise = (Math.random() - 0.5) * (0.3 + 0.05 * target);\r\n      const value = smoothed + noise;\r\n      return value < 0 ? 0 : value;\r\n    });\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    if (this.updateInterval) {\r\n      clearInterval(this.updateInterval);\r\n    }\r\n  }\r\n}"],"mappings":"AAAA,SAAqBA,MAAM,EAAEC,MAAM,EAAaC,MAAM,QAAQ,eAAe;AAC7E,SAASC,aAAa,QAAQ,kBAAkB;;AAKhD,WAAaC,kBAAkB;EAAA,IAAAC,YAAA;EAAzB,MAAOD,kBAAkB;IAW7BE,YAAA;MAVQ,KAAAC,aAAa,GAAGL,MAAM,CAACC,aAAa,CAAC;MAC7C,KAAAK,UAAU,GAAGR,MAAM,CAAC,CAAC,MAAAS,SAAA;QAAAC,SAAA;MAAA,SAAC;MAEtB;MACQ,KAAAC,kBAAkB,GAAG,CAAC;MAC9B;MACA;MACQ,KAAAC,oBAAoB,GAAkB,IAAI;MAIhD;MACA,IAAI,CAACC,cAAc,GAAGC,WAAW,CAAC,MAAM,IAAI,CAACC,SAAS,EAAE,EAAE,GAAG,CAAC;MAE9D;MACA;MACA;MACA;MACA;MACA;MACAd,MAAM,CAAC,MAAK;QACV,MAAMe,GAAG,GAAG,IAAI,CAACT,aAAa,CAACU,YAAY,EAAE;QAC7C,IAAID,GAAG,IAAI,IAAI,EAAE;UACf,IAAI,CAACL,kBAAkB,GAAGK,GAAG;UAC7B,IAAI,IAAI,CAACJ,oBAAoB,IAAI,IAAI,EAAE;YACrC,IAAI,CAACA,oBAAoB,GAAGI,GAAG;UACjC,CAAC,MAAM;YACL;YACA,MAAME,KAAK,GAAG,KAAK;YACnB,IAAI,CAACN,oBAAoB,GACvB,IAAI,CAACA,oBAAoB,GACzB,CAACI,GAAG,GAAG,IAAI,CAACJ,oBAAoB,IAAIM,KAAK;UAC7C;QACF;MACF,CAAC,CAAC;IACJ;IAEA;IACA;IACA;IACA;IACA;IACQH,SAASA,CAAA;MACf,IAAI,CAACP,UAAU,CAACW,MAAM,CAACC,OAAO,IAAG;QAC/B;QACA,MAAMC,QAAQ,GACZ,IAAI,CAACT,oBAAoB,IAAI,IAAI,GAAG,IAAI,CAACA,oBAAoB,GAAG,CAAC;QACnE,IAAIU,MAAM,GAAG,CAAC;QACd;QACA,MAAMC,IAAI,GAAG,IAAI,CAACZ,kBAAkB,GAAGU,QAAQ;QAC/C,IAAIE,IAAI,GAAG,CAAC,EAAE;UACZ;UACA;UACA;UACAD,MAAM,GAAGE,IAAI,CAACC,GAAG,CAACF,IAAI,GAAG,CAAC,EAAE,GAAG,CAAC;QAClC;QACA;QACA,MAAMG,QAAQ,GAAGN,OAAO,GAAG,CAACE,MAAM,GAAGF,OAAO,IAAI,GAAG;QACnD;QACA,MAAMO,KAAK,GAAG,CAACH,IAAI,CAACI,MAAM,EAAE,GAAG,GAAG,KAAK,GAAG,GAAG,IAAI,GAAGN,MAAM,CAAC;QAC3D,MAAMO,KAAK,GAAGH,QAAQ,GAAGC,KAAK;QAC9B,OAAOE,KAAK,GAAG,CAAC,GAAG,CAAC,GAAGA,KAAK;MAC9B,CAAC,CAAC;IACJ;IAEAC,WAAWA,CAAA;MACT,IAAI,IAAI,CAACjB,cAAc,EAAE;QACvBkB,aAAa,CAAC,IAAI,CAAClB,cAAc,CAAC;MACpC;IACF;IAAC,QAAAmB,CAAA,GAAA3B,YAAA,GAAAA,CAAA,M;uCAtEUD,kBAAkB;IAAA,G;aAAlBA,kBAAkB;MAAA6B,OAAA,EAAlB7B,kBAAkB,CAAA8B,IAAA;MAAAC,UAAA,EAFjB;IAAM;;;SAEP/B,kBAAkB;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}