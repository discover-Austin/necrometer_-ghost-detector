{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/grand/necrometer_-ghost-detector-1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { inject, signal, effect, computed } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { DeviceStateService } from '../../services/device-state.service';\nimport { SensorService } from '../../services/sensor.service';\nimport { UpgradeService } from '../../services/upgrade.service';\nimport { GeminiService } from '../../services/gemini.service';\nimport { CameraPreview } from '@capacitor-community/camera-preview';\nimport { Capacitor } from '@capacitor/core';\nimport { computeOcclusionLevel } from '../../utils/ar-utils';\nimport { AudioService } from '../../services/audio.service';\nimport { App } from '@capacitor/app';\nimport * as i0 from \"@angular/core\";\nfunction VisionComponent_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵdomElementStart(0, \"div\", 1);\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵdomElementStart(1, \"svg\", 3);\n    i0.ɵɵdomElement(2, \"path\", 4);\n    i0.ɵɵdomElementEnd();\n    i0.ɵɵnamespaceHTML();\n    i0.ɵɵdomElementStart(3, \"h2\", 5);\n    i0.ɵɵtext(4, \"Camera Access Required\");\n    i0.ɵɵdomElementEnd();\n    i0.ɵɵdomElementStart(5, \"p\", 6);\n    i0.ɵɵtext(6);\n    i0.ɵɵdomElementEnd();\n    i0.ɵɵdomElementStart(7, \"button\", 7);\n    i0.ɵɵdomListener(\"click\", function VisionComponent_Conditional_1_Template_button_click_7_listener() {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.startCamera());\n    });\n    i0.ɵɵtext(8, \" Retry \");\n    i0.ɵɵdomElementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(ctx_r1.cameraPermissionError());\n  }\n}\nexport let VisionComponent = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class VisionComponent {\n    constructor() {\n      this.deviceState = inject(DeviceStateService);\n      this.sensorService = inject(SensorService);\n      this.upgradeService = inject(UpgradeService);\n      this.geminiService = inject(GeminiService);\n      this.audioService = inject(AudioService);\n      this.arEntities = signal([], ...(ngDevMode ? [{\n        debugName: \"arEntities\"\n      }] : []));\n      this.targetedEntity = signal(null, ...(ngDevMode ? [{\n        debugName: \"targetedEntity\"\n      }] : []));\n      this.currentTime = signal(Date.now(), ...(ngDevMode ? [{\n        debugName: \"currentTime\"\n      }] : []));\n      // Camera state\n      this.isCameraActive = false;\n      this.cameraPermissionError = signal(null, ...(ngDevMode ? [{\n        debugName: \"cameraPermissionError\"\n      }] : []));\n      this.appStateListener = null;\n      // State for environmental scanning\n      this.isScanningEnvironment = signal(false, ...(ngDevMode ? [{\n        debugName: \"isScanningEnvironment\"\n      }] : []));\n      this.scanError = signal(null, ...(ngDevMode ? [{\n        debugName: \"scanError\"\n      }] : []));\n      this.sceneObjects = signal([], ...(ngDevMode ? [{\n        debugName: \"sceneObjects\"\n      }] : []));\n      this.scanCost = 5;\n      this.animationFrameId = null;\n      this.physics = {\n        gravityTilt: 0.00005,\n        downwardDrift: 0.00002,\n        friction: 0.97,\n        emfAgitation: 0.00015,\n        maxSpeed: 0.2,\n        sceneRepulsion: 0.0001,\n        sceneRepulsionRadius: 12\n      };\n      this.distortionLevel = computed(() => {\n        const reading = this.deviceState.emfReading();\n        if (reading < 40) return 0;\n        if (reading > 95) return 10;\n        return Math.floor((reading - 40) / 55 * 8) + 1; // 1-9 scale\n      }, ...(ngDevMode ? [{\n        debugName: \"distortionLevel\"\n      }] : []));\n      effect(() => {\n        this.currentTime();\n      });\n    }\n    ngOnInit() {\n      this.startAnimationLoop();\n      this.startCamera();\n      App.addListener('appStateChange', ({\n        isActive\n      }) => {\n        if (isActive && this.cameraPermissionError() && !this.isCameraActive) {\n          this.startCamera();\n        }\n      });\n    }\n    ngOnDestroy() {\n      this.stopAnimationLoop();\n      this.stopCamera();\n      this.appStateListener?.remove();\n    }\n    startCamera() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (_this.isCameraActive) return;\n        const attemptStart = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (position) {\n            yield CameraPreview.start({\n              position,\n              toBack: true,\n              parent: 'vision-camera-container',\n              className: 'camera-preview-class'\n            });\n          });\n          return function attemptStart(_x) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        try {\n          yield attemptStart('rear');\n          _this.isCameraActive = true;\n          _this.cameraPermissionError.set(null);\n        } catch (rearError) {\n          const rearErrorMessage = rearError instanceof Error ? rearError.message : String(rearError);\n          if (rearErrorMessage.toLowerCase().includes('requested device not found')) {\n            console.warn(\"Rear camera not found, attempting front camera.\");\n            try {\n              yield attemptStart('front');\n              _this.isCameraActive = true;\n              _this.cameraPermissionError.set(null);\n            } catch (frontError) {\n              const frontErrorMessage = frontError instanceof Error ? frontError.message : String(frontError);\n              if (frontErrorMessage.toLowerCase().includes('requested device not found')) {\n                console.warn(\"No camera device found (tried rear and front). Proceeding without camera preview.\");\n                _this.isCameraActive = false;\n                _this.cameraPermissionError.set(null);\n              } else {\n                console.error(\"Error starting front camera preview:\", frontError);\n                _this.handleCameraError(frontError);\n              }\n            }\n          } else {\n            console.error(\"Error starting rear camera preview:\", rearError);\n            _this.handleCameraError(rearError);\n          }\n        }\n      })();\n    }\n    handleCameraError(err) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      if (errorMessage.toLowerCase().includes('permission')) {\n        this.cameraPermissionError.set(\"Camera permission has been denied. To use Vision, please enable camera access in your device or browser's app settings.\");\n      } else if (errorMessage.toLowerCase().includes('requested device not found')) {\n        this.cameraPermissionError.set(\"No suitable camera was found on your device. The Vision feature requires a camera to function.\");\n      } else {\n        this.cameraPermissionError.set(\"Failed to start the camera. Please ensure permissions are granted and try restarting the app.\");\n      }\n    }\n    stopCamera() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this2.isCameraActive) return;\n        _this2.isCameraActive = false;\n        try {\n          yield CameraPreview.stop();\n        } catch (e) {\n          console.warn(\"Could not stop camera preview\", e);\n        }\n      })();\n    }\n    scanEnvironment() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (_this3.isScanningEnvironment()) return;\n        if (!_this3.upgradeService.spendCredits(_this3.scanCost)) {\n          _this3.scanError.set(`Insufficient Credits. Requires ${_this3.scanCost} NC.`);\n          setTimeout(() => _this3.scanError.set(null), 4000);\n          return;\n        }\n        _this3.isScanningEnvironment.set(true);\n        _this3.scanError.set(null);\n        _this3.sceneObjects.set([]);\n        try {\n          console.debug('[Vision] scanEnvironment: ensuring preview started (current previewMode:', _this3.previewMode, ')');\n          // Ensure a preview is running or fall back to web camera capture\n          let analysisResult;\n          try {\n            // If preview not started, attempt to start it (one-shot) – do not override permission-denied flag\n            const mode = _this3.previewMode ? _this3.previewMode : yield _this3.ensurePreviewStarted();\n            _this3.previewMode = mode;\n            if (mode === 'native') {\n              console.debug('[Vision] capture: using native CameraPreview.capture');\n              const result = yield CameraPreview.capture({\n                quality: 85\n              });\n              // result.value contains base64 image data for some plugin versions\n              const payload = result && result.value || result && result.base64 || null;\n              if (payload) {\n                _this3.lastCaptureSize.set(payload.length);\n              }\n              analysisResult = yield _this3.geminiService.analyzeScene(payload);\n            } else {\n              // Web fallback: draw current video frame to canvas and convert to base64 JPG\n              if (!_this3.webVideoEl || !_this3.webCanvasEl) throw new Error('Web camera not initialized');\n              const ctx = _this3.webCanvasEl.getContext('2d');\n              if (!ctx) throw new Error('Unable to get canvas context');\n              // Ensure canvas matches video size\n              _this3.webCanvasEl.width = _this3.webVideoEl.videoWidth || _this3.webCanvasEl.width || 1280;\n              _this3.webCanvasEl.height = _this3.webVideoEl.videoHeight || _this3.webCanvasEl.height || 720;\n              ctx.drawImage(_this3.webVideoEl, 0, 0, _this3.webCanvasEl.width, _this3.webCanvasEl.height);\n              const dataUrl = _this3.webCanvasEl.toDataURL('image/jpeg', 0.85);\n              const base64 = dataUrl.split(',')[1];\n              _this3.lastCaptureSize.set(base64.length);\n              console.debug('[Vision] capture: web fallback image size (bytes):', base64.length);\n              analysisResult = yield _this3.geminiService.analyzeScene(base64);\n            }\n          } catch (previewErr) {\n            console.warn('Preview capture failed, attempting direct CameraPreview.capture fallback or web fallback:', previewErr);\n            // Try direct CameraPreview.capture as a last native attempt\n            try {\n              console.debug('[Vision] capture fallback: trying CameraPreview.capture directly');\n              const result = yield CameraPreview.capture({\n                quality: 85\n              });\n              const payload = result && result.value || result && result.base64 || null;\n              if (payload) _this3.lastCaptureSize.set(payload.length);\n              analysisResult = yield _this3.geminiService.analyzeScene(payload);\n            } catch (finalErr) {\n              // If everything fails, rethrow to be handled by outer catch\n              if (finalErr && (finalErr.name === 'NotAllowedError' || /permission/i.test(String(finalErr)))) {\n                _this3.cameraPermissionDenied.set(true);\n              }\n              _this3.lastCaptureStatus.set('failed');\n              console.error('[Vision] final capture attempt failed:', finalErr);\n              throw finalErr;\n            }\n          }\n          _this3.sceneObjects.set(analysisResult.objects);\n          _this3.lastCaptureStatus.set('success');\n          console.debug('[Vision] scanEnvironment: analysisResult objects length:', analysisResult && analysisResult.objects && analysisResult.objects.length || 0);\n          // Clear results after a delay\n          setTimeout(() => _this3.sceneObjects.set([]), 15000);\n        } catch (err) {\n          console.error('Environment scan failed:', err);\n          _this3.lastCaptureStatus.set('error');\n          _this3.scanError.set('Scene analysis failed. Connection unstable.');\n          // refund credits on failure\n          _this3.upgradeService.addCredits(_this3.scanCost);\n          setTimeout(() => _this3.scanError.set(null), 4000);\n        } finally {\n          _this3.isScanningEnvironment.set(false);\n          // Keep persistent preview running; do not stop here. It will be stopped in ngOnDestroy.\n        }\n      })();\n    }\n    /** Start a persistent preview (native or web). Safe to call multiple times. */\n    startPreview() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const mode = yield _this4.ensurePreviewStarted();\n        _this4.previewMode = mode;\n        return mode;\n      })();\n    }\n    ensurePreviewStarted() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        // Prefer native CameraPreview on non-web platforms when available\n        try {\n          const platform = Capacitor && typeof Capacitor.getPlatform === 'function' ? Capacitor.getPlatform() : 'web';\n          if (platform !== 'web') {\n            try {\n              // Attach native preview to the shared camera container used by the app shell.\n              // Use toBack: true so the app UI can render translucent overlays above the camera feed.\n              yield CameraPreview.start({\n                parent: 'camera-container',\n                toBack: true,\n                position: 'rear'\n              });\n              return 'native';\n            } catch (err) {\n              console.warn('CameraPreview.start failed, falling back to web getUserMedia', err);\n            }\n          }\n        } catch (e) {\n          // ignore and try web fallback\n        }\n        // Web fallback using getUserMedia\n        if (!navigator || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n          throw new Error('No camera available');\n        }\n        // If already started, reuse\n        if (_this5.webStream && _this5.webVideoEl && _this5.webCanvasEl) return 'web';\n        // Prefer a template-bound video element if present\n        if (_this5.webPreviewRef && _this5.webPreviewRef.nativeElement) {\n          _this5.webVideoEl = _this5.webPreviewRef.nativeElement;\n          _this5.webVideoCreatedByComponent = false;\n        } else {\n          _this5.webVideoEl = document.createElement('video');\n          _this5.webVideoCreatedByComponent = true;\n        }\n        _this5.webVideoEl.autoplay = true;\n        _this5.webVideoEl.playsInline = true;\n        try {\n          _this5.webStream = yield navigator.mediaDevices.getUserMedia({\n            video: {\n              facingMode: 'environment',\n              width: {\n                ideal: 1280\n              },\n              height: {\n                ideal: 720\n              }\n            },\n            audio: false\n          });\n          _this5.webVideoEl.srcObject = _this5.webStream;\n          yield _this5.webVideoEl.play();\n          _this5.webCanvasEl = document.createElement('canvas');\n          // Set initial size; will update before capture\n          _this5.webCanvasEl.width = _this5.webVideoEl.videoWidth || 1280;\n          _this5.webCanvasEl.height = _this5.webVideoEl.videoHeight || 720;\n          return 'web';\n        } catch (err) {\n          // If permission denied, surface it to the UI\n          if (err && (err.name === 'NotAllowedError' || /permission/i.test(String(err)))) {\n            _this5.cameraPermissionDenied.set(true);\n          }\n          // Clean up partially-created resources\n          _this5.stopWebPreview();\n          throw err;\n        }\n      })();\n    }\n    retryPreview() {\n      // Clear prior permission denial and retry starting preview\n      this.cameraPermissionDenied.set(false);\n      this.startPreview().then(() => {\n        this.scanError.set(null);\n      }).catch(err => {\n        console.warn('Retry preview failed:', err);\n        this.scanError.set('Preview still unavailable. Check camera permissions.');\n        setTimeout(() => this.scanError.set(null), 4000);\n        if (err && (err.name === 'NotAllowedError' || /permission/i.test(String(err)))) {\n          this.cameraPermissionDenied.set(true);\n        }\n      });\n    }\n    togglePreview() {\n      var _this6 = this;\n      const enabled = !this.previewEnabled();\n      this.previewEnabled.set(enabled);\n      try {\n        localStorage.setItem('necrometer.previewEnabled', String(enabled));\n      } catch {}\n      if (!enabled) {\n        // stop any preview that's active\n        _asyncToGenerator(function* () {\n          try {\n            if (_this6.previewMode === 'native') {\n              try {\n                yield CameraPreview.stop();\n              } catch {}\n              ;\n            }\n          } catch {}\n          _this6.stopWebPreview();\n          _this6.previewMode = null;\n        })();\n      } else {\n        // start preview if visible\n        try {\n          // If visibility observer is present and the element is visible, start\n          if (this.visionRootRef && this.visionRootRef.nativeElement) {\n            const rect = this.visionRootRef.nativeElement.getBoundingClientRect();\n            const isVisible = rect.top < window.innerHeight && rect.bottom > 0;\n            if (isVisible) this.startPreview().catch(() => {});\n          } else {\n            this.startPreview().catch(() => {});\n          }\n        } catch {}\n      }\n    }\n    stopWebPreview() {\n      try {\n        if (this.webStream) {\n          this.webStream.getTracks().forEach(t => t.stop());\n        }\n      } catch (e) {}\n      this.webStream = null;\n      if (this.webVideoEl) {\n        try {\n          this.webVideoEl.pause();\n        } catch {}\n        ;\n        try {\n          this.webVideoEl.srcObject = null;\n        } catch {}\n        // If we created the element we can drop the reference; if it's template-bound, keep it (template owns it)\n        if (this.webVideoCreatedByComponent) this.webVideoEl = null;\n      }\n      this.webCanvasEl = null;\n    }\n    isWebPreviewActive() {\n      return this.previewMode === 'web' && !!this.webStream && !!this.webVideoEl;\n    }\n    pointsToString(points) {\n      return points.map(p => `${p.x},${p.y}`).join(' ');\n    }\n    getNewSpawnPosition() {\n      const activeSceneObjects = this.sceneObjects();\n      // 70% chance to spawn near an object if any are detected\n      const spawnBehindObject = activeSceneObjects.length > 0 && Math.random() < 0.7;\n      if (spawnBehindObject) {\n        // Pick a random object and a random polyline from it\n        const randomObject = activeSceneObjects[Math.floor(Math.random() * activeSceneObjects.length)];\n        if (randomObject.polylines.length > 0) {\n          const randomPolyline = randomObject.polylines[Math.floor(Math.random() * randomObject.polylines.length)];\n          if (randomPolyline.length > 0) {\n            // Pick a random point on that polyline\n            const randomPoint = randomPolyline[Math.floor(Math.random() * randomPolyline.length)];\n            // Spawn near this point with a small offset\n            const offsetX = (Math.random() - 0.5) * 8; // offset by up to 4%\n            const offsetY = (Math.random() - 0.5) * 8;\n            let x = randomPoint.x + offsetX;\n            let y = randomPoint.y + offsetY;\n            // Clamp values to be within the screen bounds but not on the very edge\n            x = Math.max(5, Math.min(95, x));\n            y = Math.max(5, Math.min(95, y));\n            return {\n              x,\n              y\n            };\n          }\n        }\n      }\n      // Fallback or if no objects are available: Peripheral spawning\n      let x, y;\n      // Define a 30% wide/tall exclusion zone in the center\n      const centralExclusionZone = {\n        xMin: 35,\n        xMax: 65,\n        yMin: 35,\n        yMax: 65\n      };\n      if (Math.random() < 0.5) {\n        // Spawn on top/bottom edges\n        x = Math.random() * 100;\n        y = Math.random() < 0.5 ? Math.random() * centralExclusionZone.yMin // Top area\n        : centralExclusionZone.yMax + Math.random() * (100 - centralExclusionZone.yMax); // Bottom area\n      } else {\n        // Spawn on left/right edges\n        y = Math.random() * 100;\n        x = Math.random() < 0.5 ? Math.random() * centralExclusionZone.xMin // Left area\n        : centralExclusionZone.xMax + Math.random() * (100 - centralExclusionZone.xMax); // Right area\n      }\n      // Clamp to keep them from spawning exactly on the edge and being hard to see\n      x = Math.max(5, Math.min(95, x));\n      y = Math.max(5, Math.min(95, y));\n      return {\n        x,\n        y\n      };\n    }\n    startAnimationLoop() {\n      const animate = () => {\n        this.currentTime.set(Date.now());\n        this.updateAREntities();\n        this.animationFrameId = requestAnimationFrame(animate);\n      };\n      animate();\n    }\n    stopAnimationLoop() {\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n      }\n    }\n    updateAREntities() {\n      const orientation = this.sensorService.orientation();\n      const gravityX = orientation ? orientation.gamma / 90 : 0;\n      const gravityY = orientation ? Math.max(-90, Math.min(90, orientation.beta)) / 90 : 0;\n      const activeSceneObjects = this.sceneObjects(); // Get scene objects once per frame\n      this.arEntities.update(entities => {\n        let closestEntity = null;\n        let minDistance = 15; // Targeting threshold in viewport % units\n        const emfReading = this.deviceState.emfReading();\n        const now = Date.now();\n        const updatedEntities = entities.map(e => {\n          let {\n            x,\n            y,\n            vx,\n            vy,\n            ax,\n            ay,\n            interactionTime\n          } = e;\n          if (e.contained) {\n            // Contained entities are not affected by physics and just drift to a stop.\n            vx *= 0.9;\n            vy *= 0.9;\n            x += vx;\n            y += vy;\n            return {\n              ...e,\n              x,\n              y,\n              vx,\n              vy,\n              ax: 0,\n              ay: 0,\n              isInteracting: false\n            };\n          }\n          ax = 0;\n          ay = 0;\n          // --- FORCES ---\n          // 0. Anchor spring: if anchored, gently pull towards the anchor's projected position\n          if (e.anchor) {\n            const a = e.anchor;\n            const sceneObj = activeSceneObjects[a.objectIndex];\n            if (sceneObj && sceneObj.polylines && sceneObj.polylines[a.polylineIndex]) {\n              const basePoint = sceneObj.polylines[a.polylineIndex][a.pointIndex];\n              if (basePoint) {\n                // Compute the anchor target on screen (base + stored offset)\n                const anchorX = basePoint.x + a.offsetX;\n                const anchorY = basePoint.y + a.offsetY;\n                // Spring force proportional to distance\n                const springDx = anchorX - x;\n                const springDy = anchorY - y;\n                const springStrength = 0.0008; // tuned for subtle hold\n                ax += springDx * springStrength;\n                ay += springDy * springStrength;\n                // Slight damping towards anchor\n                vx *= 0.995;\n                vy *= 0.995;\n              }\n            }\n          }\n          // 1. Gravity from device tilt\n          ax += gravityX * this.physics.gravityTilt;\n          ay += gravityY * this.physics.gravityTilt;\n          // 2. Constant downward drift to simulate being in a real space\n          ay += this.physics.downwardDrift;\n          // 3. EMF Agitation (random, erratic movements proportional to EMF)\n          const agitation = emfReading * this.physics.emfAgitation;\n          ax += (Math.random() - 0.5) * agitation;\n          ay += (Math.random() - 0.5) * agitation;\n          // 4. Repulsion from scene objects\n          let hasInteractedThisFrame = false;\n          if (activeSceneObjects.length > 0) {\n            for (const obj of activeSceneObjects) {\n              for (const polyline of obj.polylines) {\n                for (const point of polyline) {\n                  const dx = x - point.x;\n                  const dy = y - point.y;\n                  const distance = Math.sqrt(dx * dx + dy * dy);\n                  if (distance < this.physics.sceneRepulsionRadius) {\n                    hasInteractedThisFrame = true;\n                    const forceMagnitude = (this.physics.sceneRepulsionRadius - distance) * this.physics.sceneRepulsion;\n                    // Play sound with a cooldown\n                    if (!interactionTime || now - interactionTime > 500) {\n                      this.audioService.playInteractionHum();\n                      interactionTime = now;\n                    }\n                    // Avoid division by zero if distance is exactly 0\n                    if (distance > 0) {\n                      const forceX = dx / distance * forceMagnitude;\n                      const forceY = dy / distance * forceMagnitude;\n                      ax += forceX;\n                      ay += forceY;\n                    }\n                  }\n                }\n              }\n            }\n          }\n          // --- PHYSICS INTEGRATION ---\n          vx += ax;\n          vy += ay;\n          vx *= this.physics.friction;\n          vy *= this.physics.friction;\n          // Clamp speed to a maximum\n          const speed = Math.sqrt(vx * vx + vy * vy);\n          if (speed > this.physics.maxSpeed) {\n            vx = vx / speed * this.physics.maxSpeed;\n            vy = vy / speed * this.physics.maxSpeed;\n          }\n          x += vx;\n          y += vy;\n          // --- PARALLAX ---\n          // Apply a small parallax offset based on device orientation and anchored depth\n          if (e.anchor) {\n            const depth = e.anchor.depth || 1;\n            // Parallax scale: closer objects (depth ~1) move more with device tilt; farther (depth>1) move less\n            const parallaxScale = 1 / depth * 0.6; // tuned\n            const parallaxX = gravityX * parallaxScale * 6; // amplify small tilt into percent offsets\n            const parallaxY = gravityY * parallaxScale * 6;\n            x += parallaxX;\n            y += parallaxY;\n          }\n          // --- OFF-SCREEN BEHAVIOR ---\n          // If an entity drifts off the bottom, left, or right edge, reset it to appear from the top.\n          if (y > 105 || x < -5 || x > 105) {\n            x = Math.random() * 80 + 10; // Respawn at a random horizontal position\n            y = -5; // Start just above the screen\n            vx = (Math.random() - 0.5) * 0.02; // Give it a new, gentle horizontal velocity\n            vy = Math.random() * 0.05; // Ensure it drifts downwards\n          }\n          // --- SOFT OCCLUSION ---\n          const occlusionLevel = computeOcclusionLevel(e, activeSceneObjects);\n          const occluded = occlusionLevel > 0.25; // threshold to mark fully occluded for current logic\n          // Update rendering helpers: bobbing and scale modulation\n          const bobPhase = (e.bobPhase || 0) + 0.02 + emfReading * 0.0001;\n          const bobOffset = Math.sin(bobPhase) * 0.6 * (e.scale || 1);\n          const scale = (e.scale || 1) * (1 + Math.abs(bobOffset) * 0.01);\n          const rotation = (e.rotation || 0) + Math.sin(bobPhase * 0.5) * 0.2;\n          // Limb swing amplitude scales with movement speed and instability\n          const vel = Math.sqrt(vx * vx + vy * vy);\n          const baseSwing = Math.min(1.0, vel * 30 + (e.instability || 0) * 0.004);\n          const swing = Math.sin(bobPhase * 1.6) * 18 * baseSwing; // degrees\n          const armSwing = swing * 0.9;\n          const legSwing = swing;\n          const leftArmAngle = (e.leftArmAngle || 0) + (armSwing - (e.leftArmAngle || 0)) * 0.2;\n          const rightArmAngle = (e.rightArmAngle || 0) + (-armSwing - (e.rightArmAngle || 0)) * 0.2;\n          const leftLegAngle = (e.leftLegAngle || 0) + (legSwing - (e.leftLegAngle || 0)) * 0.18;\n          const rightLegAngle = (e.rightLegAngle || 0) + (-legSwing - (e.rightLegAngle || 0)) * 0.18;\n          // Facial expressions: blink periodically and mouth open based on instability/EMF\n          const blink = Math.max(0, Math.min(1, (Math.sin(bobPhase * 0.5 + vel * 5) * 0.5 + 0.5) * 0.2 - (e.instability || 0) * 0.001));\n          const mouthOpen = Math.max(0, Math.min(1, Math.abs(Math.sin(bobPhase * 0.7)) * 0.2 + (e.instability || 0) * 0.003 + emfReading * 0.0005));\n          const updatedEntity = {\n            ...e,\n            x,\n            y,\n            vx,\n            vy,\n            ax,\n            ay,\n            interactionTime,\n            isInteracting: hasInteractedThisFrame,\n            occluded,\n            occlusionLevel,\n            bobPhase,\n            scale,\n            rotation,\n            leftArmAngle,\n            rightArmAngle,\n            leftLegAngle,\n            rightLegAngle,\n            blink,\n            mouthOpen\n          };\n          // --- TARGETING ---\n          const distanceToCenter = Math.sqrt(Math.pow(updatedEntity.x - 50, 2) + Math.pow(updatedEntity.y - 45, 2));\n          if (distanceToCenter < minDistance) {\n            minDistance = distanceToCenter;\n            closestEntity = updatedEntity;\n          }\n          return updatedEntity;\n        });\n        this.targetedEntity.set(closestEntity);\n        return updatedEntities;\n      });\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function VisionComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || VisionComponent)();\n    }, this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: VisionComponent,\n      selectors: [[\"app-vision\"]],\n      inputs: {\n        detections: \"detections\"\n      },\n      decls: 3,\n      vars: 1,\n      consts: [[\"id\", \"vision-camera-container\", 1, \"relative\", \"w-full\", \"h-full\", \"bg-transparent\"], [1, \"absolute\", \"inset-0\", \"z-50\", \"flex\", \"flex-col\", \"items-center\", \"justify-center\", \"bg-black/90\", \"p-8\", \"text-center\"], [1, \"absolute\", \"inset-0\", \"z-10\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", \"fill\", \"none\", \"viewBox\", \"0 0 24 24\", \"stroke-width\", \"1.5\", \"stroke\", \"currentColor\", 1, \"w-16\", \"h-16\", \"text-red-500\", \"mb-4\"], [\"stroke-linecap\", \"round\", \"stroke-linejoin\", \"round\", \"d\", \"M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z\"], [1, \"text-2xl\", \"font-bold\", \"text-red-400\", \"mb-2\"], [1, \"text-gray-300\", \"mb-6\"], [1, \"px-6\", \"py-3\", \"bg-[var(--color-primary-600)]\", \"hover:bg-[var(--color-primary-500)]\", \"text-white\", \"font-bold\", \"rounded-lg\", \"transition-colors\", 3, \"click\"]],\n      template: function VisionComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵdomElementStart(0, \"div\", 0);\n          i0.ɵɵconditionalCreate(1, VisionComponent_Conditional_1_Template, 9, 1, \"div\", 1);\n          i0.ɵɵdomElement(2, \"div\", 2);\n          i0.ɵɵdomElementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(ctx.cameraPermissionError() ? 1 : -1);\n        }\n      },\n      dependencies: [CommonModule],\n      styles: [\"[_ngcontent-%COMP%]:root{--glitch-speed: 1.5s;--waver-speed: 10s;--waver-intensity: 1deg;--aberration-offset: 1px}.ar-container[_ngcontent-%COMP%]{overflow:hidden}.scanline[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:2px;height:100%;background:linear-gradient(to bottom,rgba(110,231,183,0) 0%,var(--color-primary-400) 50%,rgba(110,231,183,0) 100%);box-shadow:0 0 10px var(--color-primary-400);animation:_ngcontent-%COMP%_scan-anim 4s linear infinite;z-index:1}@keyframes _ngcontent-%COMP%_scan-anim{0%{transform:translate(-10px)}to{transform:translate(calc(100vw - 2px))}}.entity-glyph-container[_ngcontent-%COMP%]{position:absolute;transform:translate(-50%,-50%);width:12vmin;height:18vmin;max-width:80px;max-height:120px;will-change:transform,filter,opacity,top,left;display:flex;align-items:center;justify-content:center;transition:transform .2s ease-out;animation:_ngcontent-%COMP%_waver var(--waver-speed) infinite ease-in-out}.entity-glyph-container[_ngcontent-%COMP%]:not(.contained){--glitch-speed: calc(1.5s - (var(--distortion-level, 0) * .14s));--waver-speed: calc(10s - (var(--distortion-level, 0) * .9s));--waver-intensity: calc(1deg + (var(--distortion-level, 0) * .6deg));--aberration-offset: calc(1px + (var(--distortion-level, 0) * .7px))}.entity-glyph-container.targeted[_ngcontent-%COMP%]:not(.contained){transform:translate(-50%,-50%) scale(1.15);--waver-intensity: calc(2deg + (var(--distortion-level, 0) * .7deg));--aberration-offset: calc(2px + (var(--distortion-level, 0) * .8px))}.entity-glyph-container.critical-glitch[_ngcontent-%COMP%]:not(.contained){animation:_ngcontent-%COMP%_glitch-transform .8s cubic-bezier(.25,.46,.45,.94) both infinite,_ngcontent-%COMP%_waver var(--waver-speed) infinite ease-in-out}.entity-glyph[_ngcontent-%COMP%]{width:100%;height:100%;background-size:contain;background-repeat:no-repeat;background-position:center;filter:drop-shadow(0 0 5px var(--color-primary-500));opacity:.8;transition:filter .3s ease-in-out,opacity .3s ease-in-out}.entity-humanoid[_ngcontent-%COMP%]{width:90%;height:100%;mix-blend-mode:screen;filter:drop-shadow(0 6px 12px rgba(0,0,0,.45));transition:opacity .2s ease,transform .2s ease}.entity-humanoid[_ngcontent-%COMP%]   g[_ngcontent-%COMP%]{transform-origin:0 0;transition:transform .12s linear}.entity-humanoid[_ngcontent-%COMP%]   ellipse[_ngcontent-%COMP%], .entity-humanoid[_ngcontent-%COMP%]   circle[_ngcontent-%COMP%], .entity-humanoid[_ngcontent-%COMP%]   path[_ngcontent-%COMP%]{transition:transform .12s linear,opacity .12s linear}.entity-shadow[_ngcontent-%COMP%]{position:absolute;width:50%;height:12%;background:radial-gradient(ellipse at center,#0009,#0000002e 40%,#0000);bottom:8%;left:50%;transform:translate(-50%);border-radius:50%;transition:opacity .15s ease,transform .2s ease;z-index:-1}.entity-glyph-container.occluded[_ngcontent-%COMP%]{opacity:.18;filter:blur(.6px) saturate(.6);transform-origin:center bottom}.entity-glyph-container[_ngcontent-%COMP%]{--bob-offset: 0px}.entity-glyph-container[_ngcontent-%COMP%]   .entity-humanoid[_ngcontent-%COMP%]{transform:translateY(var(--bob-offset))}.entity-glyph-container.targeted[_ngcontent-%COMP%]   .entity-humanoid[_ngcontent-%COMP%]{filter:drop-shadow(0 10px 18px rgba(255,120,120,.12)) saturate(1.1)}.entity-glyph-container.targeted[_ngcontent-%COMP%]:not(.contained)   .entity-glyph[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_pulse-glow-targeted 1.2s infinite ease-in-out}@keyframes _ngcontent-%COMP%_ripple-effect{0%{box-shadow:0 0 #34d399b3}to{box-shadow:0 0 0 20px #34d39900}}.entity-glyph-container.interacting[_ngcontent-%COMP%]   .entity-glyph[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_ripple-effect .4s ease-out}.entity-glyph[_ngcontent-%COMP%]:before, .entity-glyph[_ngcontent-%COMP%]:after{content:\\\"\\\";position:absolute;inset:0;background-image:inherit;background-size:contain;background-repeat:no-repeat;background-position:center;mix-blend-mode:screen;transition:transform .2s ease-out;opacity:.9}.entity-glyph[_ngcontent-%COMP%]:before{background-color:red;transform:translate(var(--aberration-offset))}.entity-glyph[_ngcontent-%COMP%]:after{background-color:#0ff;transform:translate(calc(-1 * var(--aberration-offset)))}.entity-glyph-container.critical-glitch[_ngcontent-%COMP%]   .entity-glyph[_ngcontent-%COMP%]:before{animation:_ngcontent-%COMP%_glitch var(--glitch-speed) infinite}.entity-glyph-container.critical-glitch[_ngcontent-%COMP%]   .entity-glyph[_ngcontent-%COMP%]:after{animation:_ngcontent-%COMP%_glitch var(--glitch-speed) reverse infinite}.containment-field[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:120%;height:120%;border:2px solid rgba(59,130,246,.8);border-radius:50%;box-shadow:0 0 15px #3b82f6b3 inset,0 0 10px #3b82f680;animation:_ngcontent-%COMP%_pulse-contain 3s infinite ease-in-out}@keyframes _ngcontent-%COMP%_pulse-contain{0%,to{transform:translate(-50%,-50%) scale(1);opacity:.8}50%{transform:translate(-50%,-50%) scale(1.05);opacity:1}}.crosshair-hud[_ngcontent-%COMP%]{position:absolute;top:45%;left:50%;transform:translate(-50%,-50%);width:150px;height:150px;display:flex;align-items:center;justify-content:center;color:var(--color-primary-400)}.crosshair-default[_ngcontent-%COMP%], .crosshair-lock[_ngcontent-%COMP%]{width:100%;height:100%;stroke:currentColor;stroke-width:2;fill:none;transition:opacity .3s ease;position:absolute}.crosshair-lock[_ngcontent-%COMP%]{color:#f87171;animation:_ngcontent-%COMP%_lock-on .3s ease-out forwards}@keyframes _ngcontent-%COMP%_lock-on{0%{transform:scale(1.5);opacity:0}to{transform:scale(1);opacity:1}}.target-info[_ngcontent-%COMP%]{position:absolute;bottom:-60px;width:200px;text-align:center;animation:_ngcontent-%COMP%_info-fade-in .4s .1s ease-out forwards;opacity:0;background:#0009;padding:8px;border-radius:4px;border:1px solid rgba(248,113,113,.4);-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px)}.target-name[_ngcontent-%COMP%]{font-weight:700;font-size:1.1rem;color:#f87171;text-transform:uppercase;letter-spacing:.1em}.target-instability[_ngcontent-%COMP%]{margin-top:4px}.target-instability[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:.6rem;letter-spacing:.05em;color:#fca5a5;margin-bottom:2px}.instability-bar[_ngcontent-%COMP%]{width:100%;height:6px;background:#ffffff1a;border:1px solid rgba(248,113,113,.3);border-radius:2px;padding:1px}.instability-fill[_ngcontent-%COMP%]{height:100%;background:#ef4444;border-radius:1px;transition:width .3s ease}@keyframes _ngcontent-%COMP%_info-fade-in{0%{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}@keyframes _ngcontent-%COMP%_waver{0%,to{transform:translate(-50%,-50%) rotate(var(--waver-intensity))}50%{transform:translate(-50%,-50%) rotate(calc(-1 * var(--waver-intensity)))}}@keyframes _ngcontent-%COMP%_glitch{2%,64%{transform:translate(var(--aberration-offset))}65%{transform:translate(calc(-1 * var(--aberration-offset)))}}@keyframes _ngcontent-%COMP%_pulse-glow-targeted{0%,to{filter:drop-shadow(0 0 8px rgba(248,113,113,.7))}50%{filter:drop-shadow(0 0 20px rgba(248,113,113,1))}}@keyframes _ngcontent-%COMP%_glitch-transform{0%{clip-path:inset(0 0 0 0)}5%{clip-path:inset(10% 0 85% 0)}10%{clip-path:inset(90% 0 1% 0)}15%{clip-path:inset(30% 0 50% 0)}20%{clip-path:inset(0 0 0 0)}80%{clip-path:inset(0 0 0 0)}85%{clip-path:inset(80% 0 5% 0)}90%{clip-path:inset(5% 0 92% 0)}95%{clip-path:inset(40% 0 40% 0)}to{clip-path:inset(0 0 0 0)}}.scene-overlay[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}.scene-polyline[_ngcontent-%COMP%]{fill:none;stroke:var(--color-primary-400);stroke-width:.5;stroke-linecap:round;stroke-linejoin:round;filter:drop-shadow(0 0 3px var(--color-primary-400));stroke-dasharray:1000;stroke-dashoffset:1000;animation:_ngcontent-%COMP%_draw-line 2.5s ease-out forwards,_ngcontent-%COMP%_pulse-line 4s 2.5s infinite ease-in-out}@keyframes _ngcontent-%COMP%_draw-line{to{stroke-dashoffset:0}}@keyframes _ngcontent-%COMP%_pulse-line{0%,to{opacity:.8}50%{opacity:.4}}.scan-button[_ngcontent-%COMP%]{padding:10px 20px;background-color:#064e3bcc;color:var(--color-primary-300);border:1px solid var(--color-primary-600);border-radius:8px;font-weight:700;-webkit-backdrop-filter:blur(5px);backdrop-filter:blur(5px);transition:all .2s ease-in-out;cursor:pointer}.scan-button[_ngcontent-%COMP%]:hover:not(:disabled){background-color:var(--color-primary-700);color:#fff;box-shadow:0 0 15px var(--color-primary-500)}.scan-button[_ngcontent-%COMP%]:disabled{background-color:#374151b3;color:#9ca3af;cursor:not-allowed}.scan-error-toast[_ngcontent-%COMP%]{background-color:#7f1d1de6;color:#fca5a5;padding:8px 12px;border-radius:6px;font-size:.875rem;font-weight:500;border:1px solid rgb(153,27,27);animation:_ngcontent-%COMP%_fade-in-out 4s ease-in-out forwards}@keyframes _ngcontent-%COMP%_fade-in-out{0%,to{opacity:0;transform:translateY(10px)}10%,90%{opacity:1;transform:translateY(0)}}.web-preview-container[_ngcontent-%COMP%]{position:absolute;top:12px;right:12px;width:160px;height:120px;background:#00000073;border:1px solid rgba(255,255,255,.08);border-radius:8px;overflow:hidden;display:none;z-index:30;pointer-events:auto}.web-preview-container.active[_ngcontent-%COMP%]{display:block}.web-preview-video[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;background:#000}.web-preview-label[_ngcontent-%COMP%]{position:absolute;bottom:4px;left:6px;font-size:10px;color:#ffffffe6;background:#00000059;padding:2px 6px;border-radius:4px}.modal-backdrop[_ngcontent-%COMP%]{position:absolute;inset:0;background:#0009}.modal-card[_ngcontent-%COMP%]{position:relative;width:90%;max-width:420px;background:#0a0a0af2;border-radius:10px;padding:18px;box-shadow:0 10px 30px #0009;color:#fff;z-index:60}.modal-title[_ngcontent-%COMP%]{font-weight:700;margin-bottom:8px}.modal-body[_ngcontent-%COMP%]{font-size:.95rem;color:#ffffffe6;margin-bottom:12px}.modal-actions[_ngcontent-%COMP%]{display:flex;gap:8px;justify-content:flex-end}\"],\n      changeDetection: 0\n    }));\n  }\n  _staticBlock();\n  return VisionComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}