{"ast":null,"code":"import { signal, effect, inject } from '@angular/core';\nimport { SensorService } from './sensor.service';\nimport * as i0 from \"@angular/core\";\nexport let DeviceStateService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class DeviceStateService {\n    constructor() {\n      this.sensorService = inject(SensorService);\n      this.emfReading = signal(0, ...(ngDevMode ? [{\n        debugName: \"emfReading\"\n      }] : []));\n      this.lastMotion = {\n        x: 0,\n        y: 0,\n        z: 0\n      };\n      this.lastAlpha = 0;\n      // Start the update loop when the service is created\n      this.updateInterval = setInterval(() => this.updateEmf(), 100);\n      // This effect will react to sensor changes and calculate the EMF\n      effect(() => {\n        const motion = this.sensorService.motion();\n        const orientation = this.sensorService.orientation();\n        let motionSpike = 0;\n        let orientationSpike = 0;\n        if (motion) {\n          const deltaX = Math.abs(motion.x - this.lastMotion.x);\n          const deltaY = Math.abs(motion.y - this.lastMotion.y);\n          const deltaZ = Math.abs(motion.z - this.lastMotion.z);\n          const totalDelta = deltaX + deltaY + deltaZ;\n          // A sharp jerk will create a high delta\n          if (totalDelta > 15) {\n            // Threshold for a significant jerk\n            motionSpike = Math.min(totalDelta * 3, 60); // Cap the spike\n          }\n          this.lastMotion = motion;\n        }\n        if (orientation) {\n          // Check for rapid spinning\n          let deltaAlpha = Math.abs(orientation.alpha - this.lastAlpha);\n          if (deltaAlpha > 180) deltaAlpha = 360 - deltaAlpha; // Handle wrap-around from 359 to 0\n          if (deltaAlpha > 20) {\n            // Fast spin\n            orientationSpike = Math.min(deltaAlpha, 40);\n          }\n          this.lastAlpha = orientation.alpha;\n        }\n        const currentEmf = this.emfReading();\n        // Add spikes to the current reading, but don't let it go over 100\n        const newEmf = Math.min(100, currentEmf + motionSpike + orientationSpike);\n        if (newEmf > currentEmf) {\n          this.emfReading.set(newEmf);\n        }\n      });\n    }\n    // This method will handle the natural decay of the signal\n    updateEmf() {\n      this.emfReading.update(current => {\n        // Apply decay, but keep a tiny bit of base noise\n        const decay = current * 0.95;\n        const baseNoise = (Math.random() - 0.5) * 0.5;\n        return Math.max(0, decay + baseNoise);\n      });\n    }\n    ngOnDestroy() {\n      if (this.updateInterval) {\n        clearInterval(this.updateInterval);\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function DeviceStateService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DeviceStateService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: DeviceStateService,\n      factory: DeviceStateService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return DeviceStateService;\n})();","map":{"version":3,"names":["signal","effect","inject","SensorService","DeviceStateService","_staticBlock","constructor","sensorService","emfReading","ngDevMode","debugName","lastMotion","x","y","z","lastAlpha","updateInterval","setInterval","updateEmf","motion","orientation","motionSpike","orientationSpike","deltaX","Math","abs","deltaY","deltaZ","totalDelta","min","deltaAlpha","alpha","currentEmf","newEmf","set","update","current","decay","baseNoise","random","max","ngOnDestroy","clearInterval","_","factory","ɵfac","providedIn"],"sources":["C:\\Users\\grand\\necrometer_-ghost-detector-1\\src\\services\\device-state.service.ts"],"sourcesContent":["import { Injectable, signal, effect, OnDestroy, inject } from '@angular/core';\r\nimport { SensorService } from './sensor.service';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class DeviceStateService implements OnDestroy {\r\n  private sensorService = inject(SensorService);\r\n  emfReading = signal(0);\r\n\r\n  private lastMotion = { x: 0, y: 0, z: 0 };\r\n  private lastAlpha = 0;\r\n  private updateInterval: any;\r\n\r\n  constructor() {\r\n    // Start the update loop when the service is created\r\n    this.updateInterval = setInterval(() => this.updateEmf(), 100);\r\n\r\n    // This effect will react to sensor changes and calculate the EMF\r\n    effect(() => {\r\n        const motion = this.sensorService.motion();\r\n        const orientation = this.sensorService.orientation();\r\n        \r\n        let motionSpike = 0;\r\n        let orientationSpike = 0;\r\n\r\n        if (motion) {\r\n            const deltaX = Math.abs(motion.x - this.lastMotion.x);\r\n            const deltaY = Math.abs(motion.y - this.lastMotion.y);\r\n            const deltaZ = Math.abs(motion.z - this.lastMotion.z);\r\n            const totalDelta = deltaX + deltaY + deltaZ;\r\n            \r\n            // A sharp jerk will create a high delta\r\n            if (totalDelta > 15) { // Threshold for a significant jerk\r\n                motionSpike = Math.min(totalDelta * 3, 60); // Cap the spike\r\n            }\r\n            this.lastMotion = motion;\r\n        }\r\n\r\n        if (orientation) {\r\n            // Check for rapid spinning\r\n            let deltaAlpha = Math.abs(orientation.alpha - this.lastAlpha);\r\n            if (deltaAlpha > 180) deltaAlpha = 360 - deltaAlpha; // Handle wrap-around from 359 to 0\r\n            \r\n            if (deltaAlpha > 20) { // Fast spin\r\n                orientationSpike = Math.min(deltaAlpha, 40);\r\n            }\r\n            this.lastAlpha = orientation.alpha;\r\n        }\r\n\r\n        const currentEmf = this.emfReading();\r\n        // Add spikes to the current reading, but don't let it go over 100\r\n        const newEmf = Math.min(100, currentEmf + motionSpike + orientationSpike);\r\n        \r\n        if (newEmf > currentEmf) {\r\n            this.emfReading.set(newEmf);\r\n        }\r\n    });\r\n  }\r\n\r\n  // This method will handle the natural decay of the signal\r\n  private updateEmf(): void {\r\n    this.emfReading.update(current => {\r\n      // Apply decay, but keep a tiny bit of base noise\r\n      const decay = current * 0.95;\r\n      const baseNoise = (Math.random() - 0.5) * 0.5;\r\n      return Math.max(0, decay + baseNoise);\r\n    });\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    if (this.updateInterval) {\r\n      clearInterval(this.updateInterval);\r\n    }\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}