{"ast":null,"code":"import { signal, effect, inject } from '@angular/core';\nimport { SensorService } from './sensor.service';\nimport * as i0 from \"@angular/core\";\nexport let DeviceStateService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class DeviceStateService {\n    constructor() {\n      this.sensorService = inject(SensorService);\n      this.emfReading = signal(0, ...(ngDevMode ? [{\n        debugName: \"emfReading\"\n      }] : []));\n      this.lastMotion = {\n        x: 0,\n        y: 0,\n        z: 0\n      };\n      this.lastAlpha = 0;\n      // Start the update loop when the service is created\n      this.updateInterval = setInterval(() => this.updateEmf(), 100);\n      // This effect will react to sensor changes and calculate the EMF\n      effect(() => {\n        const motion = this.sensorService.motion();\n        const orientation = this.sensorService.orientation();\n        let motionSpike = 0;\n        let orientationSpike = 0;\n        if (motion) {\n          const deltaX = Math.abs(motion.x - this.lastMotion.x);\n          const deltaY = Math.abs(motion.y - this.lastMotion.y);\n          const deltaZ = Math.abs(motion.z - this.lastMotion.z);\n          const totalDelta = deltaX + deltaY + deltaZ;\n          // A sharp jerk will create a high delta\n          if (totalDelta > 15) {\n            // Threshold for a significant jerk\n            motionSpike = Math.min(totalDelta * 3, 60); // Cap the spike\n          }\n          this.lastMotion = motion;\n        }\n        if (orientation) {\n          // Check for rapid spinning\n          let deltaAlpha = Math.abs(orientation.alpha - this.lastAlpha);\n          if (deltaAlpha > 180) deltaAlpha = 360 - deltaAlpha; // Handle wrap-around from 359 to 0\n          if (deltaAlpha > 20) {\n            // Fast spin\n            orientationSpike = Math.min(deltaAlpha, 40);\n          }\n          this.lastAlpha = orientation.alpha;\n        }\n        const currentEmf = this.emfReading();\n        // Add spikes to the current reading, but don't let it go over 100\n        const newEmf = Math.min(100, currentEmf + motionSpike + orientationSpike);\n        if (newEmf > currentEmf) {\n          this.emfReading.set(newEmf);\n        }\n      });\n    }\n    // This method will handle the natural decay of the signal\n    updateEmf() {\n      this.emfReading.update(current => {\n        // Apply decay, but keep a tiny bit of base noise\n        const decay = current * 0.95;\n        const baseNoise = (Math.random() - 0.5) * 0.5;\n        return Math.max(0, decay + baseNoise);\n      });\n    }\n    ngOnDestroy() {\n      if (this.updateInterval) {\n        clearInterval(this.updateInterval);\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function DeviceStateService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DeviceStateService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: DeviceStateService,\n      factory: DeviceStateService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return DeviceStateService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}