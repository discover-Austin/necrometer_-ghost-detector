{"ast":null,"code":"import { effect } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nconst _c0 = [\"radarCanvas\"];\nexport let GeoTriangulatorComponent = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class GeoTriangulatorComponent {\n    constructor() {\n      this.emfReading = 0;\n      this.signal = null;\n      this.animationFrameId = null;\n      this.size = 0;\n      this.center = 0;\n      this.pulseCounter = 0;\n      effect(() => {\n        const reading = this.emfReading;\n        if (reading > 10 && !this.signal) {\n          this.signal = this.createSignal();\n        } else if (reading <= 10 && this.signal) {\n          this.signal = null;\n        }\n        if (this.signal) {\n          this.signal.strength = reading / 100;\n          this.signal.speed = reading / 100 * 0.05;\n        }\n      });\n    }\n    ngAfterViewInit() {\n      const canvas = this.canvasRef.nativeElement;\n      const context = canvas.getContext('2d');\n      if (!context) return;\n      this.ctx = context;\n      const rect = canvas.parentElement.getBoundingClientRect();\n      this.size = canvas.width = canvas.height = rect.width;\n      this.center = this.size / 2;\n      this.startAnimation();\n    }\n    ngOnDestroy() {\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n      }\n    }\n    createSignal() {\n      return {\n        angle: Math.random() * Math.PI * 2,\n        distance: Math.random() * (this.center * 0.8),\n        strength: 0.1,\n        speed: 0.01,\n        pulseSize: 0,\n        pulseAlpha: 0\n      };\n    }\n    startAnimation() {\n      let rotation = 0;\n      const animate = () => {\n        rotation += 0.02;\n        this.pulseCounter += 0.05;\n        this.draw(rotation);\n        this.animationFrameId = requestAnimationFrame(animate);\n      };\n      animate();\n    }\n    draw(rotation) {\n      if (!this.ctx) return;\n      this.ctx.clearRect(0, 0, this.size, this.size);\n      const readingFactor = this.emfReading / 100;\n      // Draw grid\n      this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';\n      this.ctx.lineWidth = 1;\n      for (let i = 1; i <= 3; i++) {\n        const distortion = this.center * 0.03 * Math.sin(this.pulseCounter * 0.5 + i) * readingFactor;\n        this.ctx.beginPath();\n        this.ctx.arc(this.center, this.center, this.center * 0.9 / 3 * i + distortion, 0, Math.PI * 2);\n        this.ctx.stroke();\n      }\n      // Draw sweep\n      this.ctx.save();\n      this.ctx.translate(this.center, this.center);\n      this.ctx.rotate(rotation);\n      const gradient = this.ctx.createLinearGradient(0, 0, this.center, 0);\n      gradient.addColorStop(0, 'rgba(0, 255, 0, 0)');\n      gradient.addColorStop(1, 'rgba(0, 255, 0, 0.5)');\n      this.ctx.fillStyle = gradient;\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, 0);\n      this.ctx.arc(0, 0, this.center * 0.9, 0, Math.PI * 0.25);\n      this.ctx.closePath();\n      this.ctx.fill();\n      this.ctx.restore();\n      // Draw signal\n      if (this.signal) {\n        this.signal.angle += this.signal.speed * (Math.random() - 0.5);\n        this.signal.distance += (Math.random() - 0.5) * 2;\n        this.signal.distance = Math.max(0, Math.min(this.signal.distance, this.center * 0.85));\n        const x = this.center + Math.cos(this.signal.angle) * this.signal.distance;\n        const y = this.center + Math.sin(this.signal.angle) * this.signal.distance;\n        // Color shifts from green (120) to red (0) based on strength\n        const hue = 120 - this.signal.strength * 120;\n        // Pulsing effect\n        this.signal.pulseSize = (Math.sin(this.pulseCounter * (1 + this.signal.strength * 2)) + 1) / 2; // 0 to 1\n        this.signal.pulseAlpha = 1 - this.signal.pulseSize;\n        // Draw pulse\n        this.ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${this.signal.pulseAlpha * 0.5})`;\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, 4 + this.signal.pulseSize * 10 * this.signal.strength, 0, Math.PI * 2);\n        this.ctx.fill();\n        // Draw main dot\n        this.ctx.fillStyle = `hsla(${hue}, 100%, 70%, 1)`;\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, 4, 0, Math.PI * 2);\n        this.ctx.fill();\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function GeoTriangulatorComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || GeoTriangulatorComponent)();\n    }, this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: GeoTriangulatorComponent,\n      selectors: [[\"app-geo-triangulator\"]],\n      viewQuery: function GeoTriangulatorComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvasRef = _t.first);\n        }\n      },\n      inputs: {\n        emfReading: \"emfReading\"\n      },\n      decls: 5,\n      vars: 0,\n      consts: [[\"radarCanvas\", \"\"], [1, \"relative\", \"w-full\", \"aspect-square\", \"bg-black/50\", \"rounded-lg\", \"border-2\", \"border-green-900\", \"overflow-hidden\"], [1, \"absolute\", \"inset-0\", \"w-full\", \"h-full\"], [1, \"absolute\", \"top-2\", \"left-3\", \"text-xs\", \"text-green-400\", \"uppercase\", \"tracking-widest\", \"font-bold\"]],\n      template: function GeoTriangulatorComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵdomElementStart(0, \"div\", 1);\n          i0.ɵɵdomElement(1, \"canvas\", 2, 0);\n          i0.ɵɵdomElementStart(3, \"p\", 3);\n          i0.ɵɵtext(4, \"Geo-Scanner\");\n          i0.ɵɵdomElementEnd()();\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    }));\n  }\n  _staticBlock();\n  return GeoTriangulatorComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}