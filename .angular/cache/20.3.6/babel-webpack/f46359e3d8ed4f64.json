{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/grand/necrometer_-ghost-detector-1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { GoogleGenAI, Type } from \"@google/genai\";\nimport * as i0 from \"@angular/core\";\n// A default fallback glyph in case image generation fails\nconst FALLBACK_GLYPH_B64 = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIrSURBVHhe7ZtNattAEID7/9+dFbSIIiJaNs06h5L2Wk2zJ5NCS80rFeLz4eG/4K+gKwhKBISKgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQITw3wL8/vmx0+l0vV7/8Xg8Ho/HZDI5OTkRgZfL5XA4lMvl4+PjTqfT6XQ+n//1eDyZTAY4f2S5XF6v1/P5/Gaz+fPz89ls9vf3d7/f/08G2Gw2nU7n8/kymczn87e3t3e7XZ/P93q9brdbn8/3er0+n++3f/p/Axyfz/d6vW63W5/P93q9brfL5XKpVCoVCoXC4fD1+z/9ZwAul8vlcvl8vslk8ng8zWYz4P9I0+k0mUwul8vlcnk8Hm82m1KpFAqFw+Hw+vo6kP+Pfr+fTqdzOBwOh8PpdDgcDpVKhUKhUqlUKhUKhUqlUKhUKhUKhUqlUKhUKhUKhUqlUKhUKhUKhUqlUKhUKhUqlUKhUKhUKhUqlUKhUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKh8N8T/sFj4iwy+vRp2oAAAAASUVORK5CYII=';\nexport let GeminiService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class GeminiService {\n    constructor() {\n      // Optional server-side proxy configuration\n      this.proxyBaseUrl = null;\n      this.proxyToken = null; // shared issuance token\n      this.proxyJwt = null; // short-lived JWT obtained from /issue-token\n      this.proxyJwtExpiresAt = null;\n      // Prefer server-side configuration. Do NOT automatically load an API key from browser storage.\n      // Server-side environment (Node) may provide an API key when running the server proxy.\n      let key;\n      try {\n        if (typeof process !== 'undefined' && process.env && process.env.API_KEY) {\n          key = process.env.API_KEY;\n        }\n      } catch {}\n      if (key) {\n        this.apiKey = key;\n        this.ai = new GoogleGenAI({\n          apiKey: key\n        });\n      } else {\n        // Not configured yet. Consumers must call setApiKey() (for dev) or configure proxy via setProxyConfig().\n        console.warn('GeminiService: API key not configured. Call setApiKey(apiKey) for development or setProxyConfig(baseUrl, token) to use the server proxy.');\n      }\n    }\n    /** Set API key at runtime (useful for web clients). This will instantiate the GoogleGenAI client. */\n    setApiKey(apiKey, persist = false) {\n      if (!apiKey || typeof apiKey !== 'string') throw new Error('Invalid API key');\n      // If running in a production-like environment (non-localhost), do not allow persistent client-side storage\n      const isProdHost = typeof window !== 'undefined' && window.location && window.location.hostname && !/^(localhost|127\\.0\\.0\\.1)$/.test(window.location.hostname);\n      if (persist && isProdHost) {\n        console.warn('Ignoring request to persist API key in production environment. Use the server-side proxy instead.');\n        persist = false;\n      }\n      this.apiKey = apiKey;\n      this.ai = new GoogleGenAI({\n        apiKey\n      });\n      // Do not persist by default. Persist only when explicitly requested and not in production.\n      if (persist) {\n        try {\n          localStorage.setItem('necrometer.apiKey', apiKey);\n        } catch {}\n      }\n    }\n    /** Configure a server-side proxy (base URL) and shared bearer token. When configured, some requests will be routed through the proxy. */\n    setProxyConfig(baseUrl, token) {\n      this.proxyBaseUrl = baseUrl.replace(/\\/$/, '');\n      this.proxyToken = token;\n      // clear any cached JWT when proxy config changes\n      this.proxyJwt = null;\n      this.proxyJwtExpiresAt = null;\n    }\n    // Obtain a short-lived JWT from the proxy using the shared issuance token.\n    ensureProxyJwt() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!_this.proxyBaseUrl || !_this.proxyToken) throw new Error('Proxy not configured');\n        const now = Date.now();\n        if (_this.proxyJwt && _this.proxyJwtExpiresAt && now + 5000 < _this.proxyJwtExpiresAt) {\n          return _this.proxyJwt;\n        }\n        // Request a new JWT from the proxy issuance endpoint\n        const resp = yield fetch(`${_this.proxyBaseUrl}/issue-token`, {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${_this.proxyToken}`\n          }\n        });\n        if (!resp.ok) {\n          throw new Error(`Failed to obtain proxy JWT: ${resp.status} ${yield resp.text()}`);\n        }\n        const body = yield resp.json();\n        const token = body && body.token;\n        if (!token) throw new Error('Proxy did not return a token');\n        // decode JWT expiry (simple parse of payload)\n        try {\n          const parts = token.split('.');\n          if (parts.length === 3) {\n            const payload = JSON.parse(atob(parts[1]));\n            if (payload && payload.exp) {\n              _this.proxyJwtExpiresAt = payload.exp * 1000;\n            } else {\n              _this.proxyJwtExpiresAt = Date.now() + 15 * 60 * 1000; // fallback 15m\n            }\n          }\n        } catch (_) {\n          _this.proxyJwtExpiresAt = Date.now() + 15 * 60 * 1000;\n        }\n        _this.proxyJwt = token;\n        return token;\n      })();\n    }\n    ensureConfigured() {\n      if (!this.ai && !(this.proxyBaseUrl && this.proxyToken)) {\n        throw new Error('GeminiService not configured: API key missing and proxy not configured. In production, configure the server proxy with setProxyConfig(baseUrl, token).');\n      }\n    }\n    getEntityProfile(strength) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        // Use proxy endpoint if configured\n        if (_this2.proxyBaseUrl && _this2.proxyToken) {\n          const jwt = yield _this2.ensureProxyJwt();\n          const resp = yield fetch(`${_this2.proxyBaseUrl}/api/generate-entity-profile`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': `Bearer ${jwt}`\n            },\n            body: JSON.stringify({\n              strength\n            })\n          });\n          if (!resp.ok) throw new Error(`Proxy error: ${resp.status} ${yield resp.text()}`);\n          return yield resp.json();\n        }\n        _this2.ensureConfigured();\n        const strengthDescription = _this2.getStrengthDescription(strength);\n        const profilePrompt = `Generate a short, spooky, and mysterious profile for a paranormal entity. The energy signature is ${strengthDescription}. The profile must include a plausible name, a type (e.g., Poltergeist, Shade, Revenant, Wraith, Banshee, Phantom, Lingering Spirit), a one-paragraph backstory, and an 'instability' rating (a number from 50 to 100). The entity is not yet 'contained'. Do not use markdown.`;\n        // Call the real API and propagate errors to callers (no mocks returned here)\n        const profileResponse = yield _this2.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: profilePrompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                name: {\n                  type: Type.STRING,\n                  description: 'The name of the entity.'\n                },\n                type: {\n                  type: Type.STRING,\n                  description: 'The classification of the spirit.'\n                },\n                backstory: {\n                  type: Type.STRING,\n                  description: 'A short, unsettling backstory.'\n                },\n                instability: {\n                  type: Type.NUMBER,\n                  description: 'A rating from 50-100 of how unstable the entity is.'\n                },\n                contained: {\n                  type: Type.BOOLEAN,\n                  description: 'Always false for new entities.'\n                }\n              },\n              required: ['name', 'type', 'backstory', 'instability', 'contained']\n            },\n            temperature: 1.1,\n            topP: 0.95\n          }\n        });\n        const jsonText = profileResponse.text.trim();\n        const profileData = JSON.parse(jsonText);\n        // Now generate the glyph image based on the profile\n        const glyphPrompt = `Create a single, minimalist, arcane, mystical sigil or glyph that represents a paranormal entity. The entity is a \"${profileData.type}\" known as \"${profileData.name}\". The glyph should be a stark white design on a pure black background. It should look ancient and mysterious. It should not be a picture of the entity, but a symbolic representation.`;\n        const imageResponse = yield _this2.ai.models.generateImages({\n          model: 'imagen-3.0-generate-002',\n          prompt: glyphPrompt,\n          config: {\n            numberOfImages: 1,\n            outputMimeType: 'image/png',\n            aspectRatio: '1:1'\n          }\n        });\n        const glyphB64 = imageResponse.generatedImages[0].image.imageBytes;\n        return {\n          ...profileData,\n          glyphB64\n        };\n      })();\n    }\n    analyzeScene(imageDataB64) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Analyze this image from a first-person perspective. Identify up to 5 prominent objects or structures (like a door, chair, table, window). For each object, provide a simplified, stick-figure-like outline as an array of polylines. A polyline is an array of {x, y} points. Coordinates must be percentages (0-100) relative to the image dimensions. The outlines should be very simple and abstract. Respond in JSON format. If no objects are identifiable, return an empty 'objects' array.`;\n        const imagePart = {\n          inlineData: {\n            mimeType: 'image/jpeg',\n            data: imageDataB64\n          }\n        };\n        const textPart = {\n          text: prompt\n        };\n        // Prefer proxy if configured\n        if (_this3.proxyBaseUrl && _this3.proxyToken) {\n          const jwt = yield _this3.ensureProxyJwt();\n          const resp = yield fetch(`${_this3.proxyBaseUrl}/api/analyze-scene`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': `Bearer ${jwt}`\n            },\n            body: JSON.stringify({\n              imageBase64: imageDataB64\n            })\n          });\n          if (!resp.ok) throw new Error(`Proxy error: ${resp.status} ${yield resp.text()}`);\n          return yield resp.json();\n        }\n        _this3.ensureConfigured();\n        const response = yield _this3.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: {\n            parts: [imagePart, textPart]\n          },\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                objects: {\n                  type: Type.ARRAY,\n                  items: {\n                    type: Type.OBJECT,\n                    properties: {\n                      name: {\n                        type: Type.STRING\n                      },\n                      polylines: {\n                        type: Type.ARRAY,\n                        items: {\n                          type: Type.ARRAY,\n                          items: {\n                            type: Type.OBJECT,\n                            properties: {\n                              x: {\n                                type: Type.NUMBER\n                              },\n                              y: {\n                                type: Type.NUMBER\n                              }\n                            },\n                            required: ['x', 'y']\n                          }\n                        }\n                      }\n                    },\n                    required: ['name', 'polylines']\n                  }\n                }\n              },\n              required: ['objects']\n            }\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getEVPMessage() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `I've captured Electronic Voice Phenomenon (EVP) audio static from a haunted location. From this static, invent a single, short, cryptic, and spooky phrase or sentence that sounds like it was whispered from another dimension. The phrase should be unsettling. Also provide a confidence score between 0.2 and 0.9.`;\n        _this4.ensureConfigured();\n        const response = yield _this4.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                transcription: {\n                  type: Type.STRING,\n                  description: 'The deciphered ghostly phrase.'\n                },\n                confidence: {\n                  type: Type.NUMBER,\n                  description: 'The confidence score of the analysis.'\n                }\n              },\n              required: ['transcription', 'confidence']\n            },\n            temperature: 1.2\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getTemporalEcho() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Generate a \"temporal echo\" from a haunted location. This is a brief, one-paragraph description of a dramatic, tragic, or emotionally charged historical event that could leave a spiritual residue. Be vague about the exact location, but specific about the emotions and actions. Provide a title for the event and the historical era (e.g., 'Victorian', 'Prohibition', 'Colonial').`;\n        // Use proxy if available\n        if (_this5.proxyBaseUrl && _this5.proxyToken) {\n          const jwt = yield _this5.ensureProxyJwt();\n          const resp = yield fetch(`${_this5.proxyBaseUrl}/api/temporal-echo`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': `Bearer ${jwt}`\n            }\n          });\n          if (!resp.ok) throw new Error(`Proxy error: ${resp.status} ${yield resp.text()}`);\n          return yield resp.json();\n        }\n        _this5.ensureConfigured();\n        const response = yield _this5.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                title: {\n                  type: Type.STRING,\n                  description: 'The title of the historical event.'\n                },\n                era: {\n                  type: Type.STRING,\n                  description: 'The historical era of the event.'\n                },\n                description: {\n                  type: Type.STRING,\n                  description: 'The one-paragraph description of the echo.'\n                }\n              },\n              required: ['title', 'era', 'description']\n            },\n            temperature: 1.1\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    crossReferenceEntity(entity) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Cross-reference this paranormal entity against a global spectral database: Name: \"${entity.name}\", Type: \"${entity.type}\". Is there a known record? If so, provide a short, one-paragraph summary of its history or lore. If not, state that it's an undocumented anomaly. Respond in JSON format.`;\n        _this6.ensureConfigured();\n        const response = yield _this6.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                match: {\n                  type: Type.BOOLEAN\n                },\n                details: {\n                  type: Type.STRING\n                }\n              },\n              required: ['match', 'details']\n            }\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getEmotionalResonance(entity) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Analyze the backstory of the entity known as \"${entity.name}\" to determine its dominant emotional resonance. Backstory: \"${entity.backstory}\". List the top 3 emotions (e.g., Sorrow, Rage, Confusion) and a one-sentence summary of why. Respond in JSON format.`;\n        _this7.ensureConfigured();\n        const response = yield _this7.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                emotions: {\n                  type: Type.ARRAY,\n                  items: {\n                    type: Type.STRING\n                  }\n                },\n                summary: {\n                  type: Type.STRING\n                }\n              },\n              required: ['emotions', 'summary']\n            }\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getContainmentRitual(entity) {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Generate a short, 2-step, procedural-sounding containment ritual for a paranormal entity named \"${entity.name}\" of type \"${entity.type}\". The steps should be cryptic and technical-sounding. Then provide a short, one-sentence outcome message confirming the successful containment. Respond in JSON format.`;\n        _this8.ensureConfigured();\n        const response = yield _this8.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                steps: {\n                  type: Type.ARRAY,\n                  items: {\n                    type: Type.STRING\n                  }\n                },\n                outcome: {\n                  type: Type.STRING\n                }\n              },\n              required: ['steps', 'outcome']\n            },\n            temperature: 0.9\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getStrengthDescription(strength) {\n      switch (strength) {\n        case 'weak':\n          return 'faint and fleeting';\n        case 'moderate':\n          return 'clear and present';\n        case 'strong':\n          return 'powerful and disruptive';\n        case 'critical':\n          return 'overwhelming and physically manifesting';\n        default:\n          return 'of unknown power';\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function GeminiService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || GeminiService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: GeminiService,\n      factory: GeminiService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return GeminiService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}