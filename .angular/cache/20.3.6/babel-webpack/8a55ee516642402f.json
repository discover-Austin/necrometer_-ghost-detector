{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/grand/necrometer_-ghost-detector-1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { WebPlugin } from '@capacitor/core';\nexport class CameraPreviewWeb extends WebPlugin {\n  start(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line no-async-promise-executor\n      return new Promise(/*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (resolve, reject) {\n          var _a;\n          yield navigator.mediaDevices.getUserMedia({\n            audio: !options.disableAudio,\n            video: true\n          }).then(stream => {\n            // Stop any existing stream so we can request media with different constraints based on user input\n            stream.getTracks().forEach(track => track.stop());\n          }).catch(error => {\n            reject(error);\n          });\n          const video = document.getElementById('video');\n          const parent = document.getElementById(options.parent);\n          if (!video) {\n            const videoElement = document.createElement('video');\n            videoElement.id = 'video';\n            videoElement.setAttribute('class', options.className || '');\n            // Don't flip video feed if camera is rear facing\n            if (options.position !== 'rear') {\n              videoElement.setAttribute('style', '-webkit-transform: scaleX(-1); transform: scaleX(-1);');\n            }\n            const userAgent = navigator.userAgent.toLowerCase();\n            const isSafari = userAgent.includes('safari') && !userAgent.includes('chrome');\n            // Safari on iOS needs to have the autoplay, muted and playsinline attributes set for video.play() to be successful\n            // Without these attributes videoElement.play() will throw a NotAllowedError\n            // https://developer.apple.com/documentation/webkit/delivering_video_content_for_safari\n            if (isSafari) {\n              videoElement.setAttribute('autoplay', 'true');\n              videoElement.setAttribute('muted', 'true');\n              videoElement.setAttribute('playsinline', 'true');\n            }\n            parent.appendChild(videoElement);\n            if ((_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia) {\n              const constraints = {\n                video: {\n                  width: {\n                    ideal: options.width\n                  },\n                  height: {\n                    ideal: options.height\n                  }\n                }\n              };\n              if (options.position === 'rear') {\n                constraints.video.facingMode = 'environment';\n                _this.isBackCamera = true;\n              } else {\n                _this.isBackCamera = false;\n              }\n              navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n                //video.src = window.URL.createObjectURL(stream);\n                videoElement.srcObject = stream;\n                videoElement.play();\n                resolve();\n              }, err => {\n                reject(err);\n              });\n            }\n          } else {\n            reject({\n              message: 'camera already started'\n            });\n          }\n        });\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n  startRecordVideo() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      throw _this2.unimplemented('Not implemented on web.');\n    })();\n  }\n  stopRecordVideo() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      throw _this3.unimplemented('Not implemented on web.');\n    })();\n  }\n  stop() {\n    return _asyncToGenerator(function* () {\n      const video = document.getElementById('video');\n      if (video) {\n        video.pause();\n        const st = video.srcObject;\n        const tracks = st.getTracks();\n        for (const track of tracks) {\n          track.stop();\n        }\n        video.remove();\n      }\n    })();\n  }\n  capture(options) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise(resolve => {\n        const video = document.getElementById('video');\n        const canvas = document.createElement('canvas');\n        // video.width = video.offsetWidth;\n        const context = canvas.getContext('2d');\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n        // flip horizontally back camera isn't used\n        if (!_this4.isBackCamera) {\n          context.translate(video.videoWidth, 0);\n          context.scale(-1, 1);\n        }\n        context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);\n        let base64EncodedImage;\n        if (options.quality != undefined) {\n          base64EncodedImage = canvas.toDataURL('image/jpeg', options.quality / 100.0).replace('data:image/jpeg;base64,', '');\n        } else {\n          base64EncodedImage = canvas.toDataURL('image/png').replace('data:image/png;base64,', '');\n        }\n        resolve({\n          value: base64EncodedImage\n        });\n      });\n    })();\n  }\n  captureSample(_options) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return _this5.capture(_options);\n    })();\n  }\n  getSupportedFlashModes() {\n    return _asyncToGenerator(function* () {\n      throw new Error('getSupportedFlashModes not supported under the web platform');\n    })();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  setFlashMode(_options) {\n    return _asyncToGenerator(function* () {\n      throw new Error('setFlashMode not supported under the web platform');\n    })();\n  }\n  flip() {\n    return _asyncToGenerator(function* () {\n      throw new Error('flip not supported under the web platform');\n    })();\n  }\n  setOpacity(_options) {\n    return _asyncToGenerator(function* () {\n      const video = document.getElementById('video');\n      if (!!video && !!_options['opacity']) {\n        video.style.setProperty('opacity', _options['opacity'].toString());\n      }\n    })();\n  }\n  isCameraStarted() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      throw _this6.unimplemented('Not implemented on web.');\n    })();\n  }\n}","map":{"version":3,"names":["WebPlugin","CameraPreviewWeb","start","options","_this","_asyncToGenerator","Promise","_ref","resolve","reject","_a","navigator","mediaDevices","getUserMedia","audio","disableAudio","video","then","stream","getTracks","forEach","track","stop","catch","error","document","getElementById","parent","videoElement","createElement","id","setAttribute","className","position","userAgent","toLowerCase","isSafari","includes","appendChild","constraints","width","ideal","height","facingMode","isBackCamera","srcObject","play","err","message","_x","_x2","apply","arguments","startRecordVideo","_this2","unimplemented","stopRecordVideo","_this3","pause","st","tracks","remove","capture","_this4","canvas","context","getContext","videoWidth","videoHeight","translate","scale","drawImage","base64EncodedImage","quality","undefined","toDataURL","replace","value","captureSample","_options","_this5","getSupportedFlashModes","Error","setFlashMode","flip","setOpacity","style","setProperty","toString","isCameraStarted","_this6"],"sources":["C:/Users/grand/necrometer_-ghost-detector-1/node_modules/@capacitor-community/camera-preview/dist/esm/web.js"],"sourcesContent":["import { WebPlugin } from '@capacitor/core';\nexport class CameraPreviewWeb extends WebPlugin {\n    async start(options) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve, reject) => {\n            var _a;\n            await navigator.mediaDevices\n                .getUserMedia({\n                audio: !options.disableAudio,\n                video: true,\n            })\n                .then((stream) => {\n                // Stop any existing stream so we can request media with different constraints based on user input\n                stream.getTracks().forEach((track) => track.stop());\n            })\n                .catch((error) => {\n                reject(error);\n            });\n            const video = document.getElementById('video');\n            const parent = document.getElementById(options.parent);\n            if (!video) {\n                const videoElement = document.createElement('video');\n                videoElement.id = 'video';\n                videoElement.setAttribute('class', options.className || '');\n                // Don't flip video feed if camera is rear facing\n                if (options.position !== 'rear') {\n                    videoElement.setAttribute('style', '-webkit-transform: scaleX(-1); transform: scaleX(-1);');\n                }\n                const userAgent = navigator.userAgent.toLowerCase();\n                const isSafari = userAgent.includes('safari') && !userAgent.includes('chrome');\n                // Safari on iOS needs to have the autoplay, muted and playsinline attributes set for video.play() to be successful\n                // Without these attributes videoElement.play() will throw a NotAllowedError\n                // https://developer.apple.com/documentation/webkit/delivering_video_content_for_safari\n                if (isSafari) {\n                    videoElement.setAttribute('autoplay', 'true');\n                    videoElement.setAttribute('muted', 'true');\n                    videoElement.setAttribute('playsinline', 'true');\n                }\n                parent.appendChild(videoElement);\n                if ((_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia) {\n                    const constraints = {\n                        video: {\n                            width: { ideal: options.width },\n                            height: { ideal: options.height },\n                        },\n                    };\n                    if (options.position === 'rear') {\n                        constraints.video.facingMode = 'environment';\n                        this.isBackCamera = true;\n                    }\n                    else {\n                        this.isBackCamera = false;\n                    }\n                    navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n                        //video.src = window.URL.createObjectURL(stream);\n                        videoElement.srcObject = stream;\n                        videoElement.play();\n                        resolve();\n                    }, (err) => {\n                        reject(err);\n                    });\n                }\n            }\n            else {\n                reject({ message: 'camera already started' });\n            }\n        });\n    }\n    async startRecordVideo() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async stopRecordVideo() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async stop() {\n        const video = document.getElementById('video');\n        if (video) {\n            video.pause();\n            const st = video.srcObject;\n            const tracks = st.getTracks();\n            for (const track of tracks) {\n                track.stop();\n            }\n            video.remove();\n        }\n    }\n    async capture(options) {\n        return new Promise((resolve) => {\n            const video = document.getElementById('video');\n            const canvas = document.createElement('canvas');\n            // video.width = video.offsetWidth;\n            const context = canvas.getContext('2d');\n            canvas.width = video.videoWidth;\n            canvas.height = video.videoHeight;\n            // flip horizontally back camera isn't used\n            if (!this.isBackCamera) {\n                context.translate(video.videoWidth, 0);\n                context.scale(-1, 1);\n            }\n            context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);\n            let base64EncodedImage;\n            if (options.quality != undefined) {\n                base64EncodedImage = canvas\n                    .toDataURL('image/jpeg', options.quality / 100.0)\n                    .replace('data:image/jpeg;base64,', '');\n            }\n            else {\n                base64EncodedImage = canvas.toDataURL('image/png').replace('data:image/png;base64,', '');\n            }\n            resolve({\n                value: base64EncodedImage,\n            });\n        });\n    }\n    async captureSample(_options) {\n        return this.capture(_options);\n    }\n    async getSupportedFlashModes() {\n        throw new Error('getSupportedFlashModes not supported under the web platform');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setFlashMode(_options) {\n        throw new Error('setFlashMode not supported under the web platform');\n    }\n    async flip() {\n        throw new Error('flip not supported under the web platform');\n    }\n    async setOpacity(_options) {\n        const video = document.getElementById('video');\n        if (!!video && !!_options['opacity']) {\n            video.style.setProperty('opacity', _options['opacity'].toString());\n        }\n    }\n    async isCameraStarted() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}