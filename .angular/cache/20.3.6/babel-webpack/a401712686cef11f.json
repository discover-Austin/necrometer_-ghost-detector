{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/grand/necrometer_-ghost-detector-1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Filesystem } from '@capacitor/filesystem';\nimport write_blob from 'capacitor-blob-writer';\nimport getBlobDuration from 'get-blob-duration';\nimport { RecordingStatus } from './definitions';\nimport { alreadyRecordingError, couldNotQueryPermissionStatusError, deviceCannotVoiceRecordError, emptyRecordingError, failedToFetchRecordingError, failedToRecordError, failureResponse, missingPermissionError, recordingHasNotStartedError, successResponse } from './predefined-web-responses';\n// these mime types will be checked one by one in order until one of them is found to be supported by the current browser\nconst POSSIBLE_MIME_TYPES = {\n  'audio/aac': '.aac',\n  'audio/webm;codecs=opus': '.ogg',\n  'audio/mp4': '.mp3',\n  'audio/webm': '.ogg',\n  'audio/ogg;codecs=opus': '.ogg'\n};\nconst neverResolvingPromise = () => new Promise(() => undefined);\nexport class VoiceRecorderImpl {\n  constructor() {\n    this.mediaRecorder = null;\n    this.chunks = [];\n    this.pendingResult = neverResolvingPromise();\n  }\n  static canDeviceVoiceRecord() {\n    return _asyncToGenerator(function* () {\n      var _a;\n      if (((_a = navigator === null || navigator === void 0 ? void 0 : navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia) == null || VoiceRecorderImpl.getSupportedMimeType() == null) {\n        return failureResponse();\n      } else {\n        return successResponse();\n      }\n    })();\n  }\n  startRecording(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.mediaRecorder != null) {\n        throw alreadyRecordingError();\n      }\n      const deviceCanRecord = yield VoiceRecorderImpl.canDeviceVoiceRecord();\n      if (!deviceCanRecord.value) {\n        throw deviceCannotVoiceRecordError();\n      }\n      const havingPermission = yield VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => successResponse());\n      if (!havingPermission.value) {\n        throw missingPermissionError();\n      }\n      return navigator.mediaDevices.getUserMedia({\n        audio: true\n      }).then(stream => _this.onSuccessfullyStartedRecording(stream, options)).catch(_this.onFailedToStartRecording.bind(_this));\n    })();\n  }\n  stopRecording() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.mediaRecorder == null) {\n        throw recordingHasNotStartedError();\n      }\n      try {\n        _this2.mediaRecorder.stop();\n        _this2.mediaRecorder.stream.getTracks().forEach(track => track.stop());\n        return _this2.pendingResult;\n      } catch (ignore) {\n        throw failedToFetchRecordingError();\n      } finally {\n        _this2.prepareInstanceForNextOperation();\n      }\n    })();\n  }\n  static hasAudioRecordingPermission() {\n    return _asyncToGenerator(function* () {\n      if (navigator.permissions.query == null) {\n        if (navigator.mediaDevices == null) {\n          return Promise.reject(couldNotQueryPermissionStatusError());\n        }\n        return navigator.mediaDevices.getUserMedia({\n          audio: true\n        }).then(() => successResponse()).catch(() => {\n          throw couldNotQueryPermissionStatusError();\n        });\n      }\n      return navigator.permissions.query({\n        name: 'microphone'\n      }).then(result => ({\n        value: result.state === 'granted'\n      })).catch(() => {\n        throw couldNotQueryPermissionStatusError();\n      });\n    })();\n  }\n  static requestAudioRecordingPermission() {\n    return _asyncToGenerator(function* () {\n      const havingPermission = yield VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => failureResponse());\n      if (havingPermission.value) {\n        return successResponse();\n      }\n      return navigator.mediaDevices.getUserMedia({\n        audio: true\n      }).then(() => successResponse()).catch(() => failureResponse());\n    })();\n  }\n  pauseRecording() {\n    if (this.mediaRecorder == null) {\n      throw recordingHasNotStartedError();\n    } else if (this.mediaRecorder.state === 'recording') {\n      this.mediaRecorder.pause();\n      return Promise.resolve(successResponse());\n    } else {\n      return Promise.resolve(failureResponse());\n    }\n  }\n  resumeRecording() {\n    if (this.mediaRecorder == null) {\n      throw recordingHasNotStartedError();\n    } else if (this.mediaRecorder.state === 'paused') {\n      this.mediaRecorder.resume();\n      return Promise.resolve(successResponse());\n    } else {\n      return Promise.resolve(failureResponse());\n    }\n  }\n  getCurrentStatus() {\n    if (this.mediaRecorder == null) {\n      return Promise.resolve({\n        status: RecordingStatus.NONE\n      });\n    } else if (this.mediaRecorder.state === 'recording') {\n      return Promise.resolve({\n        status: RecordingStatus.RECORDING\n      });\n    } else if (this.mediaRecorder.state === 'paused') {\n      return Promise.resolve({\n        status: RecordingStatus.PAUSED\n      });\n    } else {\n      return Promise.resolve({\n        status: RecordingStatus.NONE\n      });\n    }\n  }\n  static getSupportedMimeType() {\n    if ((MediaRecorder === null || MediaRecorder === void 0 ? void 0 : MediaRecorder.isTypeSupported) == null) return null;\n    const foundSupportedType = Object.keys(POSSIBLE_MIME_TYPES).find(type => MediaRecorder.isTypeSupported(type));\n    return foundSupportedType !== null && foundSupportedType !== void 0 ? foundSupportedType : null;\n  }\n  onSuccessfullyStartedRecording(stream, options) {\n    var _this3 = this;\n    this.pendingResult = new Promise((resolve, reject) => {\n      this.mediaRecorder = new MediaRecorder(stream);\n      this.mediaRecorder.onerror = () => {\n        this.prepareInstanceForNextOperation();\n        reject(failedToRecordError());\n      };\n      this.mediaRecorder.onstop = /*#__PURE__*/_asyncToGenerator(function* () {\n        var _a, _b, _c;\n        const mimeType = VoiceRecorderImpl.getSupportedMimeType();\n        if (mimeType == null) {\n          _this3.prepareInstanceForNextOperation();\n          reject(failedToFetchRecordingError());\n          return;\n        }\n        const blobVoiceRecording = new Blob(_this3.chunks, {\n          type: mimeType\n        });\n        if (blobVoiceRecording.size <= 0) {\n          _this3.prepareInstanceForNextOperation();\n          reject(emptyRecordingError());\n          return;\n        }\n        let uri;\n        let recordDataBase64;\n        if (options != null) {\n          const subDirectory = (_c = (_b = (_a = options.subDirectory) === null || _a === void 0 ? void 0 : _a.match(/^\\/?(.+[^/])\\/?$/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : '';\n          const path = `${subDirectory}/recording-${new Date().getTime()}${POSSIBLE_MIME_TYPES[mimeType]}`;\n          yield write_blob({\n            blob: blobVoiceRecording,\n            directory: options.directory,\n            fast_mode: true,\n            path,\n            recursive: true\n          });\n          ({\n            uri\n          } = yield Filesystem.getUri({\n            directory: options.directory,\n            path\n          }));\n        } else {\n          recordDataBase64 = yield VoiceRecorderImpl.blobToBase64(blobVoiceRecording);\n        }\n        const recordingDuration = yield getBlobDuration(blobVoiceRecording);\n        _this3.prepareInstanceForNextOperation();\n        resolve({\n          value: {\n            recordDataBase64,\n            mimeType,\n            msDuration: recordingDuration * 1000,\n            uri\n          }\n        });\n      });\n      this.mediaRecorder.ondataavailable = event => this.chunks.push(event.data);\n      this.mediaRecorder.start();\n    });\n    return successResponse();\n  }\n  onFailedToStartRecording() {\n    this.prepareInstanceForNextOperation();\n    throw failedToRecordError();\n  }\n  static blobToBase64(blob) {\n    return new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        const recordingResult = String(reader.result);\n        const splitResult = recordingResult.split('base64,');\n        const toResolve = splitResult.length > 1 ? splitResult[1] : recordingResult;\n        resolve(toResolve.trim());\n      };\n      reader.readAsDataURL(blob);\n    });\n  }\n  prepareInstanceForNextOperation() {\n    if (this.mediaRecorder != null && this.mediaRecorder.state === 'recording') {\n      try {\n        this.mediaRecorder.stop();\n      } catch (error) {\n        console.warn('While trying to stop a media recorder, an error was thrown', error);\n      }\n    }\n    this.pendingResult = neverResolvingPromise();\n    this.mediaRecorder = null;\n    this.chunks = [];\n  }\n}","map":{"version":3,"names":["Filesystem","write_blob","getBlobDuration","RecordingStatus","alreadyRecordingError","couldNotQueryPermissionStatusError","deviceCannotVoiceRecordError","emptyRecordingError","failedToFetchRecordingError","failedToRecordError","failureResponse","missingPermissionError","recordingHasNotStartedError","successResponse","POSSIBLE_MIME_TYPES","neverResolvingPromise","Promise","undefined","VoiceRecorderImpl","constructor","mediaRecorder","chunks","pendingResult","canDeviceVoiceRecord","_asyncToGenerator","_a","navigator","mediaDevices","getUserMedia","getSupportedMimeType","startRecording","options","_this","deviceCanRecord","value","havingPermission","hasAudioRecordingPermission","catch","audio","then","stream","onSuccessfullyStartedRecording","onFailedToStartRecording","bind","stopRecording","_this2","stop","getTracks","forEach","track","ignore","prepareInstanceForNextOperation","permissions","query","reject","name","result","state","requestAudioRecordingPermission","pauseRecording","pause","resolve","resumeRecording","resume","getCurrentStatus","status","NONE","RECORDING","PAUSED","MediaRecorder","isTypeSupported","foundSupportedType","Object","keys","find","type","_this3","onerror","onstop","_b","_c","mimeType","blobVoiceRecording","Blob","size","uri","recordDataBase64","subDirectory","match","path","Date","getTime","blob","directory","fast_mode","recursive","getUri","blobToBase64","recordingDuration","msDuration","ondataavailable","event","push","data","start","reader","FileReader","onloadend","recordingResult","String","splitResult","split","toResolve","length","trim","readAsDataURL","error","console","warn"],"sources":["C:/Users/grand/necrometer_-ghost-detector-1/node_modules/capacitor-voice-recorder/dist/esm/VoiceRecorderImpl.js"],"sourcesContent":["import { Filesystem } from '@capacitor/filesystem';\nimport write_blob from 'capacitor-blob-writer';\nimport getBlobDuration from 'get-blob-duration';\nimport { RecordingStatus } from './definitions';\nimport { alreadyRecordingError, couldNotQueryPermissionStatusError, deviceCannotVoiceRecordError, emptyRecordingError, failedToFetchRecordingError, failedToRecordError, failureResponse, missingPermissionError, recordingHasNotStartedError, successResponse, } from './predefined-web-responses';\n// these mime types will be checked one by one in order until one of them is found to be supported by the current browser\nconst POSSIBLE_MIME_TYPES = {\n    'audio/aac': '.aac',\n    'audio/webm;codecs=opus': '.ogg',\n    'audio/mp4': '.mp3',\n    'audio/webm': '.ogg',\n    'audio/ogg;codecs=opus': '.ogg',\n};\nconst neverResolvingPromise = () => new Promise(() => undefined);\nexport class VoiceRecorderImpl {\n    constructor() {\n        this.mediaRecorder = null;\n        this.chunks = [];\n        this.pendingResult = neverResolvingPromise();\n    }\n    static async canDeviceVoiceRecord() {\n        var _a;\n        if (((_a = navigator === null || navigator === void 0 ? void 0 : navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia) == null || VoiceRecorderImpl.getSupportedMimeType() == null) {\n            return failureResponse();\n        }\n        else {\n            return successResponse();\n        }\n    }\n    async startRecording(options) {\n        if (this.mediaRecorder != null) {\n            throw alreadyRecordingError();\n        }\n        const deviceCanRecord = await VoiceRecorderImpl.canDeviceVoiceRecord();\n        if (!deviceCanRecord.value) {\n            throw deviceCannotVoiceRecordError();\n        }\n        const havingPermission = await VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => successResponse());\n        if (!havingPermission.value) {\n            throw missingPermissionError();\n        }\n        return navigator.mediaDevices\n            .getUserMedia({ audio: true })\n            .then((stream) => this.onSuccessfullyStartedRecording(stream, options))\n            .catch(this.onFailedToStartRecording.bind(this));\n    }\n    async stopRecording() {\n        if (this.mediaRecorder == null) {\n            throw recordingHasNotStartedError();\n        }\n        try {\n            this.mediaRecorder.stop();\n            this.mediaRecorder.stream.getTracks().forEach((track) => track.stop());\n            return this.pendingResult;\n        }\n        catch (ignore) {\n            throw failedToFetchRecordingError();\n        }\n        finally {\n            this.prepareInstanceForNextOperation();\n        }\n    }\n    static async hasAudioRecordingPermission() {\n        if (navigator.permissions.query == null) {\n            if (navigator.mediaDevices == null) {\n                return Promise.reject(couldNotQueryPermissionStatusError());\n            }\n            return navigator.mediaDevices\n                .getUserMedia({ audio: true })\n                .then(() => successResponse())\n                .catch(() => {\n                throw couldNotQueryPermissionStatusError();\n            });\n        }\n        return navigator.permissions\n            .query({ name: 'microphone' })\n            .then((result) => ({ value: result.state === 'granted' }))\n            .catch(() => {\n            throw couldNotQueryPermissionStatusError();\n        });\n    }\n    static async requestAudioRecordingPermission() {\n        const havingPermission = await VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => failureResponse());\n        if (havingPermission.value) {\n            return successResponse();\n        }\n        return navigator.mediaDevices\n            .getUserMedia({ audio: true })\n            .then(() => successResponse())\n            .catch(() => failureResponse());\n    }\n    pauseRecording() {\n        if (this.mediaRecorder == null) {\n            throw recordingHasNotStartedError();\n        }\n        else if (this.mediaRecorder.state === 'recording') {\n            this.mediaRecorder.pause();\n            return Promise.resolve(successResponse());\n        }\n        else {\n            return Promise.resolve(failureResponse());\n        }\n    }\n    resumeRecording() {\n        if (this.mediaRecorder == null) {\n            throw recordingHasNotStartedError();\n        }\n        else if (this.mediaRecorder.state === 'paused') {\n            this.mediaRecorder.resume();\n            return Promise.resolve(successResponse());\n        }\n        else {\n            return Promise.resolve(failureResponse());\n        }\n    }\n    getCurrentStatus() {\n        if (this.mediaRecorder == null) {\n            return Promise.resolve({ status: RecordingStatus.NONE });\n        }\n        else if (this.mediaRecorder.state === 'recording') {\n            return Promise.resolve({ status: RecordingStatus.RECORDING });\n        }\n        else if (this.mediaRecorder.state === 'paused') {\n            return Promise.resolve({ status: RecordingStatus.PAUSED });\n        }\n        else {\n            return Promise.resolve({ status: RecordingStatus.NONE });\n        }\n    }\n    static getSupportedMimeType() {\n        if ((MediaRecorder === null || MediaRecorder === void 0 ? void 0 : MediaRecorder.isTypeSupported) == null)\n            return null;\n        const foundSupportedType = Object.keys(POSSIBLE_MIME_TYPES).find((type) => MediaRecorder.isTypeSupported(type));\n        return foundSupportedType !== null && foundSupportedType !== void 0 ? foundSupportedType : null;\n    }\n    onSuccessfullyStartedRecording(stream, options) {\n        this.pendingResult = new Promise((resolve, reject) => {\n            this.mediaRecorder = new MediaRecorder(stream);\n            this.mediaRecorder.onerror = () => {\n                this.prepareInstanceForNextOperation();\n                reject(failedToRecordError());\n            };\n            this.mediaRecorder.onstop = async () => {\n                var _a, _b, _c;\n                const mimeType = VoiceRecorderImpl.getSupportedMimeType();\n                if (mimeType == null) {\n                    this.prepareInstanceForNextOperation();\n                    reject(failedToFetchRecordingError());\n                    return;\n                }\n                const blobVoiceRecording = new Blob(this.chunks, { type: mimeType });\n                if (blobVoiceRecording.size <= 0) {\n                    this.prepareInstanceForNextOperation();\n                    reject(emptyRecordingError());\n                    return;\n                }\n                let uri;\n                let recordDataBase64;\n                if (options != null) {\n                    const subDirectory = (_c = (_b = (_a = options.subDirectory) === null || _a === void 0 ? void 0 : _a.match(/^\\/?(.+[^/])\\/?$/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : '';\n                    const path = `${subDirectory}/recording-${new Date().getTime()}${POSSIBLE_MIME_TYPES[mimeType]}`;\n                    await write_blob({\n                        blob: blobVoiceRecording,\n                        directory: options.directory,\n                        fast_mode: true,\n                        path,\n                        recursive: true,\n                    });\n                    ({ uri } = await Filesystem.getUri({ directory: options.directory, path }));\n                }\n                else {\n                    recordDataBase64 = await VoiceRecorderImpl.blobToBase64(blobVoiceRecording);\n                }\n                const recordingDuration = await getBlobDuration(blobVoiceRecording);\n                this.prepareInstanceForNextOperation();\n                resolve({ value: { recordDataBase64, mimeType, msDuration: recordingDuration * 1000, uri } });\n            };\n            this.mediaRecorder.ondataavailable = (event) => this.chunks.push(event.data);\n            this.mediaRecorder.start();\n        });\n        return successResponse();\n    }\n    onFailedToStartRecording() {\n        this.prepareInstanceForNextOperation();\n        throw failedToRecordError();\n    }\n    static blobToBase64(blob) {\n        return new Promise((resolve) => {\n            const reader = new FileReader();\n            reader.onloadend = () => {\n                const recordingResult = String(reader.result);\n                const splitResult = recordingResult.split('base64,');\n                const toResolve = splitResult.length > 1 ? splitResult[1] : recordingResult;\n                resolve(toResolve.trim());\n            };\n            reader.readAsDataURL(blob);\n        });\n    }\n    prepareInstanceForNextOperation() {\n        if (this.mediaRecorder != null && this.mediaRecorder.state === 'recording') {\n            try {\n                this.mediaRecorder.stop();\n            }\n            catch (error) {\n                console.warn('While trying to stop a media recorder, an error was thrown', error);\n            }\n        }\n        this.pendingResult = neverResolvingPromise();\n        this.mediaRecorder = null;\n        this.chunks = [];\n    }\n}\n"],"mappings":";AAAA,SAASA,UAAU,QAAQ,uBAAuB;AAClD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,SAASC,eAAe,QAAQ,eAAe;AAC/C,SAASC,qBAAqB,EAAEC,kCAAkC,EAAEC,4BAA4B,EAAEC,mBAAmB,EAAEC,2BAA2B,EAAEC,mBAAmB,EAAEC,eAAe,EAAEC,sBAAsB,EAAEC,2BAA2B,EAAEC,eAAe,QAAS,4BAA4B;AACnS;AACA,MAAMC,mBAAmB,GAAG;EACxB,WAAW,EAAE,MAAM;EACnB,wBAAwB,EAAE,MAAM;EAChC,WAAW,EAAE,MAAM;EACnB,YAAY,EAAE,MAAM;EACpB,uBAAuB,EAAE;AAC7B,CAAC;AACD,MAAMC,qBAAqB,GAAGA,CAAA,KAAM,IAAIC,OAAO,CAAC,MAAMC,SAAS,CAAC;AAChE,OAAO,MAAMC,iBAAiB,CAAC;EAC3BC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,aAAa,GAAGP,qBAAqB,CAAC,CAAC;EAChD;EACA,OAAaQ,oBAAoBA,CAAA,EAAG;IAAA,OAAAC,iBAAA;MAChC,IAAIC,EAAE;MACN,IAAI,CAAC,CAACA,EAAE,GAAGC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACC,YAAY,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,YAAY,KAAK,IAAI,IAAIV,iBAAiB,CAACW,oBAAoB,CAAC,CAAC,IAAI,IAAI,EAAE;QACxM,OAAOnB,eAAe,CAAC,CAAC;MAC5B,CAAC,MACI;QACD,OAAOG,eAAe,CAAC,CAAC;MAC5B;IAAC;EACL;EACMiB,cAAcA,CAACC,OAAO,EAAE;IAAA,IAAAC,KAAA;IAAA,OAAAR,iBAAA;MAC1B,IAAIQ,KAAI,CAACZ,aAAa,IAAI,IAAI,EAAE;QAC5B,MAAMhB,qBAAqB,CAAC,CAAC;MACjC;MACA,MAAM6B,eAAe,SAASf,iBAAiB,CAACK,oBAAoB,CAAC,CAAC;MACtE,IAAI,CAACU,eAAe,CAACC,KAAK,EAAE;QACxB,MAAM5B,4BAA4B,CAAC,CAAC;MACxC;MACA,MAAM6B,gBAAgB,SAASjB,iBAAiB,CAACkB,2BAA2B,CAAC,CAAC,CAACC,KAAK,CAAC,MAAMxB,eAAe,CAAC,CAAC,CAAC;MAC7G,IAAI,CAACsB,gBAAgB,CAACD,KAAK,EAAE;QACzB,MAAMvB,sBAAsB,CAAC,CAAC;MAClC;MACA,OAAOe,SAAS,CAACC,YAAY,CACxBC,YAAY,CAAC;QAAEU,KAAK,EAAE;MAAK,CAAC,CAAC,CAC7BC,IAAI,CAAEC,MAAM,IAAKR,KAAI,CAACS,8BAA8B,CAACD,MAAM,EAAET,OAAO,CAAC,CAAC,CACtEM,KAAK,CAACL,KAAI,CAACU,wBAAwB,CAACC,IAAI,CAACX,KAAI,CAAC,CAAC;IAAC;EACzD;EACMY,aAAaA,CAAA,EAAG;IAAA,IAAAC,MAAA;IAAA,OAAArB,iBAAA;MAClB,IAAIqB,MAAI,CAACzB,aAAa,IAAI,IAAI,EAAE;QAC5B,MAAMR,2BAA2B,CAAC,CAAC;MACvC;MACA,IAAI;QACAiC,MAAI,CAACzB,aAAa,CAAC0B,IAAI,CAAC,CAAC;QACzBD,MAAI,CAACzB,aAAa,CAACoB,MAAM,CAACO,SAAS,CAAC,CAAC,CAACC,OAAO,CAAEC,KAAK,IAAKA,KAAK,CAACH,IAAI,CAAC,CAAC,CAAC;QACtE,OAAOD,MAAI,CAACvB,aAAa;MAC7B,CAAC,CACD,OAAO4B,MAAM,EAAE;QACX,MAAM1C,2BAA2B,CAAC,CAAC;MACvC,CAAC,SACO;QACJqC,MAAI,CAACM,+BAA+B,CAAC,CAAC;MAC1C;IAAC;EACL;EACA,OAAaf,2BAA2BA,CAAA,EAAG;IAAA,OAAAZ,iBAAA;MACvC,IAAIE,SAAS,CAAC0B,WAAW,CAACC,KAAK,IAAI,IAAI,EAAE;QACrC,IAAI3B,SAAS,CAACC,YAAY,IAAI,IAAI,EAAE;UAChC,OAAOX,OAAO,CAACsC,MAAM,CAACjD,kCAAkC,CAAC,CAAC,CAAC;QAC/D;QACA,OAAOqB,SAAS,CAACC,YAAY,CACxBC,YAAY,CAAC;UAAEU,KAAK,EAAE;QAAK,CAAC,CAAC,CAC7BC,IAAI,CAAC,MAAM1B,eAAe,CAAC,CAAC,CAAC,CAC7BwB,KAAK,CAAC,MAAM;UACb,MAAMhC,kCAAkC,CAAC,CAAC;QAC9C,CAAC,CAAC;MACN;MACA,OAAOqB,SAAS,CAAC0B,WAAW,CACvBC,KAAK,CAAC;QAAEE,IAAI,EAAE;MAAa,CAAC,CAAC,CAC7BhB,IAAI,CAAEiB,MAAM,KAAM;QAAEtB,KAAK,EAAEsB,MAAM,CAACC,KAAK,KAAK;MAAU,CAAC,CAAC,CAAC,CACzDpB,KAAK,CAAC,MAAM;QACb,MAAMhC,kCAAkC,CAAC,CAAC;MAC9C,CAAC,CAAC;IAAC;EACP;EACA,OAAaqD,+BAA+BA,CAAA,EAAG;IAAA,OAAAlC,iBAAA;MAC3C,MAAMW,gBAAgB,SAASjB,iBAAiB,CAACkB,2BAA2B,CAAC,CAAC,CAACC,KAAK,CAAC,MAAM3B,eAAe,CAAC,CAAC,CAAC;MAC7G,IAAIyB,gBAAgB,CAACD,KAAK,EAAE;QACxB,OAAOrB,eAAe,CAAC,CAAC;MAC5B;MACA,OAAOa,SAAS,CAACC,YAAY,CACxBC,YAAY,CAAC;QAAEU,KAAK,EAAE;MAAK,CAAC,CAAC,CAC7BC,IAAI,CAAC,MAAM1B,eAAe,CAAC,CAAC,CAAC,CAC7BwB,KAAK,CAAC,MAAM3B,eAAe,CAAC,CAAC,CAAC;IAAC;EACxC;EACAiD,cAAcA,CAAA,EAAG;IACb,IAAI,IAAI,CAACvC,aAAa,IAAI,IAAI,EAAE;MAC5B,MAAMR,2BAA2B,CAAC,CAAC;IACvC,CAAC,MACI,IAAI,IAAI,CAACQ,aAAa,CAACqC,KAAK,KAAK,WAAW,EAAE;MAC/C,IAAI,CAACrC,aAAa,CAACwC,KAAK,CAAC,CAAC;MAC1B,OAAO5C,OAAO,CAAC6C,OAAO,CAAChD,eAAe,CAAC,CAAC,CAAC;IAC7C,CAAC,MACI;MACD,OAAOG,OAAO,CAAC6C,OAAO,CAACnD,eAAe,CAAC,CAAC,CAAC;IAC7C;EACJ;EACAoD,eAAeA,CAAA,EAAG;IACd,IAAI,IAAI,CAAC1C,aAAa,IAAI,IAAI,EAAE;MAC5B,MAAMR,2BAA2B,CAAC,CAAC;IACvC,CAAC,MACI,IAAI,IAAI,CAACQ,aAAa,CAACqC,KAAK,KAAK,QAAQ,EAAE;MAC5C,IAAI,CAACrC,aAAa,CAAC2C,MAAM,CAAC,CAAC;MAC3B,OAAO/C,OAAO,CAAC6C,OAAO,CAAChD,eAAe,CAAC,CAAC,CAAC;IAC7C,CAAC,MACI;MACD,OAAOG,OAAO,CAAC6C,OAAO,CAACnD,eAAe,CAAC,CAAC,CAAC;IAC7C;EACJ;EACAsD,gBAAgBA,CAAA,EAAG;IACf,IAAI,IAAI,CAAC5C,aAAa,IAAI,IAAI,EAAE;MAC5B,OAAOJ,OAAO,CAAC6C,OAAO,CAAC;QAAEI,MAAM,EAAE9D,eAAe,CAAC+D;MAAK,CAAC,CAAC;IAC5D,CAAC,MACI,IAAI,IAAI,CAAC9C,aAAa,CAACqC,KAAK,KAAK,WAAW,EAAE;MAC/C,OAAOzC,OAAO,CAAC6C,OAAO,CAAC;QAAEI,MAAM,EAAE9D,eAAe,CAACgE;MAAU,CAAC,CAAC;IACjE,CAAC,MACI,IAAI,IAAI,CAAC/C,aAAa,CAACqC,KAAK,KAAK,QAAQ,EAAE;MAC5C,OAAOzC,OAAO,CAAC6C,OAAO,CAAC;QAAEI,MAAM,EAAE9D,eAAe,CAACiE;MAAO,CAAC,CAAC;IAC9D,CAAC,MACI;MACD,OAAOpD,OAAO,CAAC6C,OAAO,CAAC;QAAEI,MAAM,EAAE9D,eAAe,CAAC+D;MAAK,CAAC,CAAC;IAC5D;EACJ;EACA,OAAOrC,oBAAoBA,CAAA,EAAG;IAC1B,IAAI,CAACwC,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACC,eAAe,KAAK,IAAI,EACrG,OAAO,IAAI;IACf,MAAMC,kBAAkB,GAAGC,MAAM,CAACC,IAAI,CAAC3D,mBAAmB,CAAC,CAAC4D,IAAI,CAAEC,IAAI,IAAKN,aAAa,CAACC,eAAe,CAACK,IAAI,CAAC,CAAC;IAC/G,OAAOJ,kBAAkB,KAAK,IAAI,IAAIA,kBAAkB,KAAK,KAAK,CAAC,GAAGA,kBAAkB,GAAG,IAAI;EACnG;EACA9B,8BAA8BA,CAACD,MAAM,EAAET,OAAO,EAAE;IAAA,IAAA6C,MAAA;IAC5C,IAAI,CAACtD,aAAa,GAAG,IAAIN,OAAO,CAAC,CAAC6C,OAAO,EAAEP,MAAM,KAAK;MAClD,IAAI,CAAClC,aAAa,GAAG,IAAIiD,aAAa,CAAC7B,MAAM,CAAC;MAC9C,IAAI,CAACpB,aAAa,CAACyD,OAAO,GAAG,MAAM;QAC/B,IAAI,CAAC1B,+BAA+B,CAAC,CAAC;QACtCG,MAAM,CAAC7C,mBAAmB,CAAC,CAAC,CAAC;MACjC,CAAC;MACD,IAAI,CAACW,aAAa,CAAC0D,MAAM,gBAAAtD,iBAAA,CAAG,aAAY;QACpC,IAAIC,EAAE,EAAEsD,EAAE,EAAEC,EAAE;QACd,MAAMC,QAAQ,GAAG/D,iBAAiB,CAACW,oBAAoB,CAAC,CAAC;QACzD,IAAIoD,QAAQ,IAAI,IAAI,EAAE;UAClBL,MAAI,CAACzB,+BAA+B,CAAC,CAAC;UACtCG,MAAM,CAAC9C,2BAA2B,CAAC,CAAC,CAAC;UACrC;QACJ;QACA,MAAM0E,kBAAkB,GAAG,IAAIC,IAAI,CAACP,MAAI,CAACvD,MAAM,EAAE;UAAEsD,IAAI,EAAEM;QAAS,CAAC,CAAC;QACpE,IAAIC,kBAAkB,CAACE,IAAI,IAAI,CAAC,EAAE;UAC9BR,MAAI,CAACzB,+BAA+B,CAAC,CAAC;UACtCG,MAAM,CAAC/C,mBAAmB,CAAC,CAAC,CAAC;UAC7B;QACJ;QACA,IAAI8E,GAAG;QACP,IAAIC,gBAAgB;QACpB,IAAIvD,OAAO,IAAI,IAAI,EAAE;UACjB,MAAMwD,YAAY,GAAG,CAACP,EAAE,GAAG,CAACD,EAAE,GAAG,CAACtD,EAAE,GAAGM,OAAO,CAACwD,YAAY,MAAM,IAAI,IAAI9D,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC+D,KAAK,CAAC,kBAAkB,CAAC,MAAM,IAAI,IAAIT,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,MAAM,IAAI,IAAIC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE;UAC/M,MAAMS,IAAI,GAAG,GAAGF,YAAY,cAAc,IAAIG,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,GAAG7E,mBAAmB,CAACmE,QAAQ,CAAC,EAAE;UAChG,MAAMhF,UAAU,CAAC;YACb2F,IAAI,EAAEV,kBAAkB;YACxBW,SAAS,EAAE9D,OAAO,CAAC8D,SAAS;YAC5BC,SAAS,EAAE,IAAI;YACfL,IAAI;YACJM,SAAS,EAAE;UACf,CAAC,CAAC;UACF,CAAC;YAAEV;UAAI,CAAC,SAASrF,UAAU,CAACgG,MAAM,CAAC;YAAEH,SAAS,EAAE9D,OAAO,CAAC8D,SAAS;YAAEJ;UAAK,CAAC,CAAC;QAC9E,CAAC,MACI;UACDH,gBAAgB,SAASpE,iBAAiB,CAAC+E,YAAY,CAACf,kBAAkB,CAAC;QAC/E;QACA,MAAMgB,iBAAiB,SAAShG,eAAe,CAACgF,kBAAkB,CAAC;QACnEN,MAAI,CAACzB,+BAA+B,CAAC,CAAC;QACtCU,OAAO,CAAC;UAAE3B,KAAK,EAAE;YAAEoD,gBAAgB;YAAEL,QAAQ;YAAEkB,UAAU,EAAED,iBAAiB,GAAG,IAAI;YAAEb;UAAI;QAAE,CAAC,CAAC;MACjG,CAAC;MACD,IAAI,CAACjE,aAAa,CAACgF,eAAe,GAAIC,KAAK,IAAK,IAAI,CAAChF,MAAM,CAACiF,IAAI,CAACD,KAAK,CAACE,IAAI,CAAC;MAC5E,IAAI,CAACnF,aAAa,CAACoF,KAAK,CAAC,CAAC;IAC9B,CAAC,CAAC;IACF,OAAO3F,eAAe,CAAC,CAAC;EAC5B;EACA6B,wBAAwBA,CAAA,EAAG;IACvB,IAAI,CAACS,+BAA+B,CAAC,CAAC;IACtC,MAAM1C,mBAAmB,CAAC,CAAC;EAC/B;EACA,OAAOwF,YAAYA,CAACL,IAAI,EAAE;IACtB,OAAO,IAAI5E,OAAO,CAAE6C,OAAO,IAAK;MAC5B,MAAM4C,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;MAC/BD,MAAM,CAACE,SAAS,GAAG,MAAM;QACrB,MAAMC,eAAe,GAAGC,MAAM,CAACJ,MAAM,CAACjD,MAAM,CAAC;QAC7C,MAAMsD,WAAW,GAAGF,eAAe,CAACG,KAAK,CAAC,SAAS,CAAC;QACpD,MAAMC,SAAS,GAAGF,WAAW,CAACG,MAAM,GAAG,CAAC,GAAGH,WAAW,CAAC,CAAC,CAAC,GAAGF,eAAe;QAC3E/C,OAAO,CAACmD,SAAS,CAACE,IAAI,CAAC,CAAC,CAAC;MAC7B,CAAC;MACDT,MAAM,CAACU,aAAa,CAACvB,IAAI,CAAC;IAC9B,CAAC,CAAC;EACN;EACAzC,+BAA+BA,CAAA,EAAG;IAC9B,IAAI,IAAI,CAAC/B,aAAa,IAAI,IAAI,IAAI,IAAI,CAACA,aAAa,CAACqC,KAAK,KAAK,WAAW,EAAE;MACxE,IAAI;QACA,IAAI,CAACrC,aAAa,CAAC0B,IAAI,CAAC,CAAC;MAC7B,CAAC,CACD,OAAOsE,KAAK,EAAE;QACVC,OAAO,CAACC,IAAI,CAAC,4DAA4D,EAAEF,KAAK,CAAC;MACrF;IACJ;IACA,IAAI,CAAC9F,aAAa,GAAGP,qBAAqB,CAAC,CAAC;IAC5C,IAAI,CAACK,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,MAAM,GAAG,EAAE;EACpB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}