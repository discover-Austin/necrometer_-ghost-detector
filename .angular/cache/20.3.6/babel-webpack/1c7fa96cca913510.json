{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/grand/necrometer_-ghost-detector-1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nexport let AudioService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class AudioService {\n    constructor() {\n      this.audioContext = null;\n      this.staticGainNode = null;\n      this.staticSource = null;\n      this.isInitialized = false;\n      this.isStaticPlaying = false;\n      this.sounds = {\n        uiClick: null,\n        detection: null,\n        success: null,\n        contain: null,\n        staticLoop: null,\n        interactionHum: null\n      };\n    }\n    loadSound(url) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!_this.audioContext) return null;\n        try {\n          const response = yield fetch(url);\n          const arrayBuffer = yield response.arrayBuffer();\n          return yield _this.audioContext.decodeAudioData(arrayBuffer);\n        } catch (error) {\n          console.error(`Failed to load sound: ${url}`, error);\n          return null;\n        }\n      })();\n    }\n    init() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (_this2.isInitialized || typeof window === 'undefined') return;\n        // Audio context must be created after a user gesture\n        _this2.audioContext = new AudioContext();\n        _this2.isInitialized = true;\n        // Load all sounds using base64 data URIs to avoid CORS issues\n        _this2.sounds.uiClick = yield _this2.loadSound('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAADQBEADgASwBHAEUARgA+ADwAOwA6ADcANgA1ADcANwA4ADgAOQA6ADsAPAA+AEAAQgBDAEUA');\n        _this2.sounds.detection = yield _this2.loadSound('data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVwAAAAAQz9APz09Ozc3NjQzMjAxMC8uLSwrKikoJyYlJCMhICAfHh0cGhsaFhUTERAQDw4NDAsKCQgHBgUEAwIBAAAA/v/5+fn49/f39fX18/Pz7+/v6+vr5+fn4+Pj3t7e2dnZ1dXV0tLSz8/Py8vLycnJxsbGxcXFw8PDu7u7srKyq6urpqampaWlpKSkoaGhoKCgn5+fnZ2dnJycm5ubmZmZl5eXlpaWk5OTkpKSkZGRj4+Pjo6OjY2NjIyMi4uLiYmJh4eHhoaGg4ODgoKCgYGBgICAf39/fX19fHx8e3t7enp6eXl5eHh4d3d3dXV1dHR0c3NzcXFxcHBwb29vbm5ubW1tbGxsampqaWlpaGhoZ2dnZmZmW1tbWlpaWVlZWFhYV1dXVVVVUlJS');\n        _this2.sounds.success = yield _this2.loadSound('data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUgAAACAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgID');\n        _this2.sounds.contain = yield _this2.loadSound('data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVwAAAAAMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM=');\n        _this2.sounds.staticLoop = yield _this2.loadSound('data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUgAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCg==');\n        _this2.sounds.interactionHum = yield _this2.loadSound('data:audio/wav;base64,UklGRlYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVIAAAAAPz9AQEBAPz8/Pz8/Pj49PTw8PDs7Ozo6Ojk5OTg4ODc3NjY2NTU1NDQzMzIyMjExMTAwLy8uLSwrKyoqKSkoKCcnJyMTExMjIyMzM0NDU1NjY3Nzg4OTk6Ojs8PD09Pj4/P0BA');\n      })();\n    }\n    playSound(buffer, gain = 1.0) {\n      if (!this.audioContext || !buffer) return;\n      const source = this.audioContext.createBufferSource();\n      const gainNode = this.audioContext.createGain();\n      source.buffer = buffer;\n      gainNode.gain.value = gain;\n      source.connect(gainNode);\n      gainNode.connect(this.audioContext.destination);\n      source.start(0);\n    }\n    startStatic() {\n      if (!this.audioContext || this.isStaticPlaying || !this.sounds.staticLoop) return;\n      this.staticSource = this.audioContext.createBufferSource();\n      this.staticSource.buffer = this.sounds.staticLoop;\n      this.staticSource.loop = true;\n      this.staticGainNode = this.audioContext.createGain();\n      this.staticSource.connect(this.staticGainNode);\n      this.staticGainNode.connect(this.audioContext.destination);\n      this.staticSource.start(0);\n      this.isStaticPlaying = true;\n    }\n    playUISound() {\n      this.playSound(this.sounds.uiClick, 0.5);\n    }\n    playDetectionSound() {\n      this.playSound(this.sounds.detection, 0.8);\n    }\n    playSuccessSound() {\n      this.playSound(this.sounds.success);\n    }\n    playContainSound() {\n      this.playSound(this.sounds.contain);\n    }\n    playInteractionHum() {\n      this.playSound(this.sounds.interactionHum, 0.3);\n    }\n    updateStaticLevel(emfReading) {\n      if (!this.isInitialized) {\n        this.init().then(() => this.updateStaticLevel(emfReading));\n        return;\n      }\n      if (!this.isStaticPlaying) {\n        this.startStatic();\n      }\n      if (this.staticGainNode && this.audioContext) {\n        // Map EMF reading (0-100) to a pleasant volume level (0 to ~0.4)\n        const maxVolume = 0.4;\n        const targetVolume = emfReading / 100 * maxVolume;\n        // Use setTargetAtTime for smooth volume transitions\n        this.staticGainNode.gain.setTargetAtTime(targetVolume, this.audioContext.currentTime, 0.1);\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function AudioService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AudioService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AudioService,\n      factory: AudioService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return AudioService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}