{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/grand/necrometer_-ghost-detector-1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nexport let AudioService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class AudioService {\n    constructor() {\n      this.audioContext = null;\n      this.staticGainNode = null;\n      this.staticSource = null;\n      this.isInitialized = false;\n      this.isStaticPlaying = false;\n      this.sounds = {\n        uiClick: null,\n        detection: null,\n        success: null,\n        contain: null,\n        staticLoop: null,\n        interactionHum: null\n      };\n    }\n    loadSound(url) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!_this.audioContext) return null;\n        try {\n          const response = yield fetch(url);\n          const arrayBuffer = yield response.arrayBuffer();\n          return yield _this.audioContext.decodeAudioData(arrayBuffer);\n        } catch (error) {\n          console.error(`Failed to load sound: ${url}`, error);\n          return null;\n        }\n      })();\n    }\n    init() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (_this2.isInitialized || typeof window === 'undefined') return;\n        // Audio context must be created after a user gesture\n        _this2.audioContext = new AudioContext();\n        _this2.isInitialized = true;\n        // Load all sounds using base64 data URIs to avoid CORS issues\n        _this2.sounds.uiClick = yield _this2.loadSound('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAADQBEADgASwBHAEUARgA+ADwAOwA6ADcANgA1ADcANwA4ADgAOQA6ADsAPAA+AEAAQgBDAEUA');\n        _this2.sounds.detection = yield _this2.loadSound('data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVwAAAAAQz9APz09Ozc3NjQzMjAxMC8uLSwrKikoJyYlJCMhICAfHh0cGhsaFhUTERAQDw4NDAsKCQgHBgUEAwIBAAAA/v/5+fn49/f39fX18/Pz7+/v6+vr5+fn4+Pj3t7e2dnZ1dXV0tLSz8/Py8vLycnJxsbGxcXFw8PDu7u7srKyq6urpqampaWlpKSkoaGhoKCgn5+fnZ2dnJycm5ubmZmZl5eXlpaWk5OTkpKSkZGRj4+Pjo6OjY2NjIyMi4uLiYmJh4eHhoaGg4ODgoKCgYGBgICAf39/fX19fHx8e3t7enp6eXl5eHh4d3d3dXV1dHR0c3NzcXFxcHBwb29vbm5ubW1tbGxsampqaWlpaGhoZ2dnZmZmW1tbWlpaWVlZWFhYV1dXVVVVUlJS');\n        _this2.sounds.success = yield _this2.loadSound('data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUgAAACAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgID');\n        _this2.sounds.contain = yield _this2.loadSound('data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVwAAAAAMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM=');\n        _this2.sounds.staticLoop = yield _this2.loadSound('data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUgAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCg==');\n        _this2.sounds.interactionHum = yield _this2.loadSound('data:audio/wav;base64,UklGRlYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVIAAAAAPz9AQEBAPz8/Pz8/Pj49PTw8PDs7Ozo6Ojk5OTg4ODc3NjY2NTU1NDQzMzIyMjExMTAwLy8uLSwrKyoqKSkoKCcnJyMTExMjIyMzM0NDU1NjY3Nzg4OTk6Ojs8PD09Pj4/P0BA');\n      })();\n    }\n    playSound(buffer, gain = 1.0) {\n      if (!this.audioContext || !buffer) return;\n      const source = this.audioContext.createBufferSource();\n      const gainNode = this.audioContext.createGain();\n      source.buffer = buffer;\n      gainNode.gain.value = gain;\n      source.connect(gainNode);\n      gainNode.connect(this.audioContext.destination);\n      source.start(0);\n    }\n    startStatic() {\n      if (!this.audioContext || this.isStaticPlaying || !this.sounds.staticLoop) return;\n      this.staticSource = this.audioContext.createBufferSource();\n      this.staticSource.buffer = this.sounds.staticLoop;\n      this.staticSource.loop = true;\n      this.staticGainNode = this.audioContext.createGain();\n      this.staticSource.connect(this.staticGainNode);\n      this.staticGainNode.connect(this.audioContext.destination);\n      this.staticSource.start(0);\n      this.isStaticPlaying = true;\n    }\n    playUISound() {\n      this.playSound(this.sounds.uiClick, 0.5);\n    }\n    playDetectionSound() {\n      this.playSound(this.sounds.detection, 0.8);\n    }\n    playSuccessSound() {\n      this.playSound(this.sounds.success);\n    }\n    playContainSound() {\n      this.playSound(this.sounds.contain);\n    }\n    playInteractionHum() {\n      this.playSound(this.sounds.interactionHum, 0.3);\n    }\n    updateStaticLevel(emfReading) {\n      if (!this.isInitialized) {\n        this.init().then(() => this.updateStaticLevel(emfReading));\n        return;\n      }\n      if (!this.isStaticPlaying) {\n        this.startStatic();\n      }\n      if (this.staticGainNode && this.audioContext) {\n        // Map EMF reading (0-100) to a pleasant volume level (0 to ~0.4)\n        const maxVolume = 0.4;\n        const targetVolume = emfReading / 100 * maxVolume;\n        // Use setTargetAtTime for smooth volume transitions\n        this.staticGainNode.gain.setTargetAtTime(targetVolume, this.audioContext.currentTime, 0.1);\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function AudioService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AudioService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AudioService,\n      factory: AudioService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return AudioService;\n})();","map":{"version":3,"names":["AudioService","_staticBlock","constructor","audioContext","staticGainNode","staticSource","isInitialized","isStaticPlaying","sounds","uiClick","detection","success","contain","staticLoop","interactionHum","loadSound","url","_this","_asyncToGenerator","response","fetch","arrayBuffer","decodeAudioData","error","console","init","_this2","window","AudioContext","playSound","buffer","gain","source","createBufferSource","gainNode","createGain","value","connect","destination","start","startStatic","loop","playUISound","playDetectionSound","playSuccessSound","playContainSound","playInteractionHum","updateStaticLevel","emfReading","then","maxVolume","targetVolume","setTargetAtTime","currentTime","_","factory","ɵfac","providedIn"],"sources":["C:\\Users\\grand\\necrometer_-ghost-detector-1\\src\\services\\audio.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class AudioService {\r\n  private audioContext: AudioContext | null = null;\r\n  private staticGainNode: GainNode | null = null;\r\n  private staticSource: AudioBufferSourceNode | null = null;\r\n  private isInitialized = false;\r\n  private isStaticPlaying = false;\r\n\r\n  private sounds: { [key: string]: AudioBuffer | null } = {\r\n    uiClick: null,\r\n    detection: null,\r\n    success: null,\r\n    contain: null,\r\n    staticLoop: null,\r\n    interactionHum: null,\r\n  };\r\n\r\n  private async loadSound(url: string): Promise<AudioBuffer | null> {\r\n    if (!this.audioContext) return null;\r\n    try {\r\n      const response = await fetch(url);\r\n      const arrayBuffer = await response.arrayBuffer();\r\n      return await this.audioContext.decodeAudioData(arrayBuffer);\r\n    } catch (error) {\r\n      console.error(`Failed to load sound: ${url}`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async init() {\r\n    if (this.isInitialized || typeof window === 'undefined') return;\r\n    \r\n    // Audio context must be created after a user gesture\r\n    this.audioContext = new AudioContext();\r\n    this.isInitialized = true;\r\n\r\n    // Load all sounds using base64 data URIs to avoid CORS issues\r\n    this.sounds.uiClick = await this.loadSound('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAADQBEADgASwBHAEUARgA+ADwAOwA6ADcANgA1ADcANwA4ADgAOQA6ADsAPAA+AEAAQgBDAEUA');\r\n    this.sounds.detection = await this.loadSound('data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVwAAAAAQz9APz09Ozc3NjQzMjAxMC8uLSwrKikoJyYlJCMhICAfHh0cGhsaFhUTERAQDw4NDAsKCQgHBgUEAwIBAAAA/v/5+fn49/f39fX18/Pz7+/v6+vr5+fn4+Pj3t7e2dnZ1dXV0tLSz8/Py8vLycnJxsbGxcXFw8PDu7u7srKyq6urpqampaWlpKSkoaGhoKCgn5+fnZ2dnJycm5ubmZmZl5eXlpaWk5OTkpKSkZGRj4+Pjo6OjY2NjIyMi4uLiYmJh4eHhoaGg4ODgoKCgYGBgICAf39/fX19fHx8e3t7enp6eXl5eHh4d3d3dXV1dHR0c3NzcXFxcHBwb29vbm5ubW1tbGxsampqaWlpaGhoZ2dnZmZmW1tbWlpaWVlZWFhYV1dXVVVVUlJS');\r\n    this.sounds.success = await this.loadSound('data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUgAAACAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgIDAwMDAgID');\r\n    this.sounds.contain = await this.loadSound('data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVwAAAAAMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM=');\r\n    this.sounds.staticLoop = await this.loadSound('data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUgAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCg==');\r\n    this.sounds.interactionHum = await this.loadSound('data:audio/wav;base64,UklGRlYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVIAAAAAPz9AQEBAPz8/Pz8/Pj49PTw8PDs7Ozo6Ojk5OTg4ODc3NjY2NTU1NDQzMzIyMjExMTAwLy8uLSwrKyoqKSkoKCcnJyMTExMjIyMzM0NDU1NjY3Nzg4OTk6Ojs8PD09Pj4/P0BA');\r\n  }\r\n\r\n  private playSound(buffer: AudioBuffer | null, gain = 1.0) {\r\n    if (!this.audioContext || !buffer) return;\r\n    const source = this.audioContext.createBufferSource();\r\n    const gainNode = this.audioContext.createGain();\r\n    source.buffer = buffer;\r\n    gainNode.gain.value = gain;\r\n    source.connect(gainNode);\r\n    gainNode.connect(this.audioContext.destination);\r\n    source.start(0);\r\n  }\r\n  \r\n  private startStatic() {\r\n     if (!this.audioContext || this.isStaticPlaying || !this.sounds.staticLoop) return;\r\n      this.staticSource = this.audioContext.createBufferSource();\r\n      this.staticSource.buffer = this.sounds.staticLoop;\r\n      this.staticSource.loop = true;\r\n      this.staticGainNode = this.audioContext.createGain();\r\n      this.staticSource.connect(this.staticGainNode);\r\n      this.staticGainNode.connect(this.audioContext.destination);\r\n      this.staticSource.start(0);\r\n      this.isStaticPlaying = true;\r\n  }\r\n  \r\n  playUISound() {\r\n    this.playSound(this.sounds.uiClick, 0.5);\r\n  }\r\n\r\n  playDetectionSound() {\r\n    this.playSound(this.sounds.detection, 0.8);\r\n  }\r\n\r\n  playSuccessSound() {\r\n    this.playSound(this.sounds.success);\r\n  }\r\n\r\n  playContainSound() {\r\n    this.playSound(this.sounds.contain);\r\n  }\r\n\r\n  playInteractionHum() {\r\n    this.playSound(this.sounds.interactionHum, 0.3);\r\n  }\r\n\r\n  updateStaticLevel(emfReading: number) {\r\n    if (!this.isInitialized) {\r\n        this.init().then(() => this.updateStaticLevel(emfReading));\r\n        return;\r\n    }\r\n    \r\n    if (!this.isStaticPlaying) {\r\n        this.startStatic();\r\n    }\r\n\r\n    if (this.staticGainNode && this.audioContext) {\r\n      // Map EMF reading (0-100) to a pleasant volume level (0 to ~0.4)\r\n      const maxVolume = 0.4;\r\n      const targetVolume = (emfReading / 100) * maxVolume;\r\n      // Use setTargetAtTime for smooth volume transitions\r\n      this.staticGainNode.gain.setTargetAtTime(targetVolume, this.audioContext.currentTime, 0.1);\r\n    }\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}