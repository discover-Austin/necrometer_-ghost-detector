{"ast":null,"code":"/*jslint browser */\n\nimport { Capacitor, registerPlugin } from \"@capacitor/core\";\nimport { Filesystem } from \"@capacitor/filesystem\";\nconst BlobWriter = registerPlugin(\"BlobWriter\");\nfunction array_buffer_to_base64(buffer) {\n  return window.btoa(Array.from(new Uint8Array(buffer)).map(function (byte) {\n    return String.fromCharCode(byte);\n  }).join(\"\"));\n}\nfunction write_file_via_indexeddb({\n  path,\n  directory,\n  blob,\n  recursive\n}) {\n  // Firstly, create the file entry in the database. This populates a bunch of\n  // properties on the entry, such as mtime, ctime and type, and also gives the\n  // Filesystem plugin a chance to initialize its database.\n\n  return Filesystem.writeFile({\n    directory,\n    path,\n    recursive,\n    data: \"\"\n  }).then(function () {\n    // Now reach into IndexedDB and assign 'blob' to the file entry.\n\n    return new Promise(function (resolve, reject) {\n      function fail(event) {\n        reject(event.target.error);\n      }\n      const connection = window.indexedDB.open(\"Disc\");\n      connection.onerror = fail;\n      connection.onsuccess = function () {\n        const db = connection.result;\n        const transaction = db.transaction(\"FileStorage\", \"readwrite\");\n        transaction.onerror = fail;\n        const store = transaction.objectStore(\"FileStorage\");\n        const name = `/${directory}/${path.replace(/^\\//, \"\")}`;\n        const load = store.get(name);\n        load.onsuccess = function () {\n          load.result.size = blob.size;\n          load.result.content = blob;\n          const put = store.put(load.result);\n          put.onsuccess = function () {\n            resolve(undefined);\n          };\n        };\n      };\n    });\n  });\n}\nfunction write_file_via_bridge({\n  path,\n  directory,\n  blob,\n  recursive\n}) {\n  // Firstly, create or truncate the file.\n\n  return Filesystem.writeFile({\n    directory,\n    path,\n    recursive,\n    data: \"\"\n  }).then(function consume_blob() {\n    // Now write the file incrementally so that we do not exhaust our memory in\n    // attempting to Base64 encode the entire Blob at once.\n\n    if (blob.size === 0) {\n      return Promise.resolve();\n    }\n\n    // By choosing a chunk size which is a multiple of 3, we avoid a bug in\n    // Filesystem.appendFile, only on the web platform, which corrupts files by\n    // inserting Base64 padding characters within the file. See\n    // https://github.com/ionic-team/capacitor-plugins/issues/649.\n\n    const chunk_size = 3 * 128 * 1024;\n    const chunk_blob = blob.slice(0, chunk_size);\n    blob = blob.slice(chunk_size);\n\n    // Read the Blob as an ArrayBuffer, then append it to the file on disk.\n\n    return new Response(chunk_blob).arrayBuffer().then(function append_chunk_to_file(buffer) {\n      return Filesystem.appendFile({\n        directory,\n        path,\n        data: array_buffer_to_base64(buffer)\n      });\n    }).then(consume_blob);\n  });\n}\nfunction write_blob(options) {\n  const {\n    path,\n    directory,\n    blob,\n    fast_mode = false,\n    recursive,\n    on_fallback\n  } = options;\n  if (!blob || !Number.isSafeInteger(blob.size) || typeof blob.type !== \"string\") {\n    return Promise.reject(new Error(\"Not a Blob.\"));\n  }\n  if (Capacitor.getPlatform() === \"web\") {\n    return fast_mode ? write_file_via_indexeddb(options) : write_file_via_bridge(options);\n  }\n  return Promise.all([BlobWriter.get_config(), Filesystem.getUri({\n    path,\n    directory\n  })]).then(function ([config, file_info]) {\n    const absolute_path = file_info.uri.replace(\"file://\", \"\");\n\n    // The built-in CapacitorHttp plugin can be configured to monkey patch the\n    // global 'fetch' function, but that forces 'blob' over the bridge which is\n    // what we're trying to avoid. We attempt to subvert the monkey patching.\n\n    const real_fetch = window.CapacitorWebFetch || window.fetch;\n    return real_fetch(config.base_url + absolute_path + (recursive ? \"?recursive=true\" : \"\"), {\n      headers: {\n        authorization: config.auth_token\n      },\n      method: \"put\",\n      body: blob\n    }).then(function (response) {\n      if (response.status !== 204) {\n        throw new Error(\"Bad HTTP status: \" + response.status);\n      }\n\n      // Producing a file URI is deprecated. In the next major version, the returned\n      // Promise should resolve to undefined.\n\n      return file_info.uri;\n    });\n  }).catch(function on_fail(error) {\n    if (on_fallback !== undefined) {\n      on_fallback(error);\n    }\n    return write_file_via_bridge(options);\n  });\n}\nexport default Object.freeze(write_blob);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}