{"ast":null,"code":"import { signal, effect, inject } from '@angular/core';\nimport { SensorService } from './sensor.service';\nimport * as i0 from \"@angular/core\";\nexport let DeviceStateService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class DeviceStateService {\n    constructor() {\n      this.sensorService = inject(SensorService);\n      this.emfReading = signal(0, ...(ngDevMode ? [{\n        debugName: \"emfReading\"\n      }] : []));\n      // Latest magnetometer magnitude (µT) reported by SensorService.magnetometer().\n      this.latestMagnetometer = 0;\n      // Exponentially smoothed baseline value to compensate for the Earth's magnetic field.\n      // The baseline will slowly adapt to environmental changes.\n      this.baselineMagnetometer = null;\n      // Start the update loop when the service is created\n      this.updateInterval = setInterval(() => this.updateEmf(), 100);\n      // React to changes in the magnetometer reading.  Update the latest\n      // magnitude and slowly adjust the baseline value to compensate for\n      // the Earth's magnetic field.  The baseline is updated using a very\n      // low smoothing factor (0.001) so that it adapts over minutes rather\n      // than seconds.  If baseline is not yet set, initialize it on first\n      // reading.\n      effect(() => {\n        const mag = this.sensorService.magnetometer();\n        if (mag != null) {\n          this.latestMagnetometer = mag;\n          if (this.baselineMagnetometer == null) {\n            this.baselineMagnetometer = mag;\n          } else {\n            // exponential smoothing: baseline += (mag - baseline) * alpha\n            const alpha = 0.001;\n            this.baselineMagnetometer = this.baselineMagnetometer + (mag - this.baselineMagnetometer) * alpha;\n          }\n        }\n      });\n    }\n    // Smoothly update the EMF reading towards a value derived from the\n    // magnetometer.  The target EMF value is the difference between the\n    // latest magnitude and the slowly-adapting baseline, scaled up to a\n    // 0–100 range to match the UI.  A small amount of noise is added\n    // proportional to the current target to mimic sensor jitter.\n    updateEmf() {\n      this.emfReading.update(current => {\n        // Ensure we have a baseline; if not, fall back to raw magnitude\n        const baseline = this.baselineMagnetometer != null ? this.baselineMagnetometer : 0;\n        let target = 0;\n        // compute difference; clamp to zero\n        const diff = this.latestMagnetometer - baseline;\n        if (diff > 0) {\n          // Scale difference to the UI range.  Earth's field ranges from\n          // ~25–65 µT, so differences of a few microteslas should produce\n          // modest readings.  Multiply by 3 and cap at 100.\n          target = Math.min(diff * 3, 100);\n        }\n        // move 10% towards the target each tick for smoothing\n        const smoothed = current + (target - current) * 0.1;\n        // noise scales with target: more agitation when target is high\n        const noise = (Math.random() - 0.5) * (0.3 + 0.05 * target);\n        const value = smoothed + noise;\n        return value < 0 ? 0 : value;\n      });\n    }\n    ngOnDestroy() {\n      if (this.updateInterval) {\n        clearInterval(this.updateInterval);\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function DeviceStateService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DeviceStateService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: DeviceStateService,\n      factory: DeviceStateService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return DeviceStateService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}