{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/grand/necrometer_-ghost-detector-1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { GoogleGenAI, Type } from \"@google/genai\";\nimport * as i0 from \"@angular/core\";\n// A default fallback glyph in case image generation fails\nconst FALLBACK_GLYPH_B64 = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIrSURBVHhe7ZtNattAEID7/9+dFbSIIiJaNs06h5L2Wk2zJ5NCS80rFeLz4eG/4K+gKwhKBISKgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQITw3wL8/vmx0+l0vV7/8Xg8Ho/HZDI5OTkRgZfL5XA4lMvl4+PjTqfT6XQ+n//1eDyZTAY4f2S5XF6v1/P5/Gaz+fPz89ls9vf3d7/f/08G2Gw2nU7n8/kymczn87e3t3e7XZ/P93q9brdbn8/3er0+n++3f/p/Axyfz/d6vW63W5/P93q9brfL5XKpVCoVCoXC4fD1+z/9ZwAul8vlcvl8vslk8ng8zWYz4P9I0+k0mUwul8vlcnk8Hm82m1KpFAqFw+Hw+vo6kP+Pfr+fTqdzOBwOh8PpdDgcDpVKhUKhUqlUKhUKhUqlUKhUKhUKhUqlUKhUKhUKhUqlUKhUKhUKhUqlUKhUKhUqlUKhUKhUKhUqlUKhUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKh8N8T/sFj4iwy+vRp2oAAAAASUVORK5CYII=';\nexport let GeminiService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class GeminiService {\n    constructor() {\n      // Optional server-side proxy configuration\n      this.proxyBaseUrl = null;\n      this.proxyToken = null; // shared issuance token\n      this.proxyJwt = null; // short-lived JWT obtained from /issue-token\n      this.proxyJwtExpiresAt = null;\n      // Prefer server-side configuration. Do NOT automatically load an API key from browser storage.\n      // Server-side environment (Node) may provide an API key when running the server proxy.\n      let key;\n      try {\n        if (typeof process !== 'undefined' && process.env && process.env.API_KEY) {\n          key = process.env.API_KEY;\n        }\n      } catch {}\n      if (key) {\n        this.apiKey = key;\n        this.ai = new GoogleGenAI({\n          apiKey: key\n        });\n      } else {\n        // Not configured yet. Consumers must call setApiKey() (for dev) or configure proxy via setProxyConfig().\n        console.warn('GeminiService: API key not configured. Call setApiKey(apiKey) for development or setProxyConfig(baseUrl, token) to use the server proxy.');\n      }\n    }\n    /** Set API key at runtime (useful for web clients). This will instantiate the GoogleGenAI client. */\n    setApiKey(apiKey, persist = false) {\n      if (!apiKey || typeof apiKey !== 'string') throw new Error('Invalid API key');\n      // If running in a production-like environment (non-localhost), do not allow persistent client-side storage\n      const isProdHost = typeof window !== 'undefined' && window.location && window.location.hostname && !/^(localhost|127\\.0\\.0\\.1)$/.test(window.location.hostname);\n      if (persist && isProdHost) {\n        console.warn('Ignoring request to persist API key in production environment. Use the server-side proxy instead.');\n        persist = false;\n      }\n      this.apiKey = apiKey;\n      this.ai = new GoogleGenAI({\n        apiKey\n      });\n      // Do not persist by default. Persist only when explicitly requested and not in production.\n      if (persist) {\n        try {\n          localStorage.setItem('necrometer.apiKey', apiKey);\n        } catch {}\n      }\n    }\n    /** Configure a server-side proxy (base URL) and shared bearer token. When configured, some requests will be routed through the proxy. */\n    setProxyConfig(baseUrl, token) {\n      this.proxyBaseUrl = baseUrl.replace(/\\/$/, '');\n      this.proxyToken = token;\n      // clear any cached JWT when proxy config changes\n      this.proxyJwt = null;\n      this.proxyJwtExpiresAt = null;\n    }\n    // Obtain a short-lived JWT from the proxy using the shared issuance token.\n    ensureProxyJwt() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!_this.proxyBaseUrl || !_this.proxyToken) throw new Error('Proxy not configured');\n        const now = Date.now();\n        if (_this.proxyJwt && _this.proxyJwtExpiresAt && now + 5000 < _this.proxyJwtExpiresAt) {\n          return _this.proxyJwt;\n        }\n        // Request a new JWT from the proxy issuance endpoint\n        const resp = yield fetch(`${_this.proxyBaseUrl}/issue-token`, {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${_this.proxyToken}`\n          }\n        });\n        if (!resp.ok) {\n          throw new Error(`Failed to obtain proxy JWT: ${resp.status} ${yield resp.text()}`);\n        }\n        const body = yield resp.json();\n        const token = body && body.token;\n        if (!token) throw new Error('Proxy did not return a token');\n        // decode JWT expiry (simple parse of payload)\n        try {\n          const parts = token.split('.');\n          if (parts.length === 3) {\n            const payload = JSON.parse(atob(parts[1]));\n            if (payload && payload.exp) {\n              _this.proxyJwtExpiresAt = payload.exp * 1000;\n            } else {\n              _this.proxyJwtExpiresAt = Date.now() + 15 * 60 * 1000; // fallback 15m\n            }\n          }\n        } catch (_) {\n          _this.proxyJwtExpiresAt = Date.now() + 15 * 60 * 1000;\n        }\n        _this.proxyJwt = token;\n        return token;\n      })();\n    }\n    ensureConfigured() {\n      if (!this.ai && !(this.proxyBaseUrl && this.proxyToken)) {\n        throw new Error('GeminiService not configured: API key missing and proxy not configured. In production, configure the server proxy with setProxyConfig(baseUrl, token).');\n      }\n    }\n    getEntityProfile(strength) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        // Use proxy endpoint if configured\n        if (_this2.proxyBaseUrl && _this2.proxyToken) {\n          const jwt = yield _this2.ensureProxyJwt();\n          const resp = yield fetch(`${_this2.proxyBaseUrl}/api/generate-entity-profile`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': `Bearer ${jwt}`\n            },\n            body: JSON.stringify({\n              strength\n            })\n          });\n          if (!resp.ok) throw new Error(`Proxy error: ${resp.status} ${yield resp.text()}`);\n          return yield resp.json();\n        }\n        _this2.ensureConfigured();\n        const strengthDescription = _this2.getStrengthDescription(strength);\n        const profilePrompt = `Generate a short, spooky, and mysterious profile for a paranormal entity. The energy signature is ${strengthDescription}. The profile must include a plausible name, a type (e.g., Poltergeist, Shade, Revenant, Wraith, Banshee, Phantom, Lingering Spirit), a one-paragraph backstory, and an 'instability' rating (a number from 50 to 100). The entity is not yet 'contained'. Do not use markdown.`;\n        // Call the real API and propagate errors to callers (no mocks returned here)\n        const profileResponse = yield _this2.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: profilePrompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                name: {\n                  type: Type.STRING,\n                  description: 'The name of the entity.'\n                },\n                type: {\n                  type: Type.STRING,\n                  description: 'The classification of the spirit.'\n                },\n                backstory: {\n                  type: Type.STRING,\n                  description: 'A short, unsettling backstory.'\n                },\n                instability: {\n                  type: Type.NUMBER,\n                  description: 'A rating from 50-100 of how unstable the entity is.'\n                },\n                contained: {\n                  type: Type.BOOLEAN,\n                  description: 'Always false for new entities.'\n                }\n              },\n              required: ['name', 'type', 'backstory', 'instability', 'contained']\n            },\n            temperature: 1.1,\n            topP: 0.95\n          }\n        });\n        const jsonText = profileResponse.text.trim();\n        const profileData = JSON.parse(jsonText);\n        // Now generate the glyph image based on the profile\n        const glyphPrompt = `Create a single, minimalist, arcane, mystical sigil or glyph that represents a paranormal entity. The entity is a \"${profileData.type}\" known as \"${profileData.name}\". The glyph should be a stark white design on a pure black background. It should look ancient and mysterious. It should not be a picture of the entity, but a symbolic representation.`;\n        const imageResponse = yield _this2.ai.models.generateImages({\n          model: 'imagen-3.0-generate-002',\n          prompt: glyphPrompt,\n          config: {\n            numberOfImages: 1,\n            outputMimeType: 'image/png',\n            aspectRatio: '1:1'\n          }\n        });\n        const glyphB64 = imageResponse.generatedImages[0].image.imageBytes;\n        return {\n          ...profileData,\n          glyphB64\n        };\n      })();\n    }\n    analyzeScene(imageDataB64) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Analyze this image from a first-person perspective. Identify up to 5 prominent objects or structures (like a door, chair, table, window). For each object, provide a simplified, stick-figure-like outline as an array of polylines. A polyline is an array of {x, y} points. Coordinates must be percentages (0-100) relative to the image dimensions. The outlines should be very simple and abstract. Respond in JSON format. If no objects are identifiable, return an empty 'objects' array.`;\n        const imagePart = {\n          inlineData: {\n            mimeType: 'image/jpeg',\n            data: imageDataB64\n          }\n        };\n        const textPart = {\n          text: prompt\n        };\n        // Prefer proxy if configured\n        if (_this3.proxyBaseUrl && _this3.proxyToken) {\n          const jwt = yield _this3.ensureProxyJwt();\n          const resp = yield fetch(`${_this3.proxyBaseUrl}/api/analyze-scene`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': `Bearer ${jwt}`\n            },\n            body: JSON.stringify({\n              imageBase64: imageDataB64\n            })\n          });\n          if (!resp.ok) throw new Error(`Proxy error: ${resp.status} ${yield resp.text()}`);\n          return yield resp.json();\n        }\n        _this3.ensureConfigured();\n        const response = yield _this3.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: {\n            parts: [imagePart, textPart]\n          },\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                objects: {\n                  type: Type.ARRAY,\n                  items: {\n                    type: Type.OBJECT,\n                    properties: {\n                      name: {\n                        type: Type.STRING\n                      },\n                      polylines: {\n                        type: Type.ARRAY,\n                        items: {\n                          type: Type.ARRAY,\n                          items: {\n                            type: Type.OBJECT,\n                            properties: {\n                              x: {\n                                type: Type.NUMBER\n                              },\n                              y: {\n                                type: Type.NUMBER\n                              }\n                            },\n                            required: ['x', 'y']\n                          }\n                        }\n                      }\n                    },\n                    required: ['name', 'polylines']\n                  }\n                }\n              },\n              required: ['objects']\n            }\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getEVPMessage() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `I've captured Electronic Voice Phenomenon (EVP) audio static from a haunted location. From this static, invent a single, short, cryptic, and spooky phrase or sentence that sounds like it was whispered from another dimension. The phrase should be unsettling. Also provide a confidence score between 0.2 and 0.9.`;\n        _this4.ensureConfigured();\n        const response = yield _this4.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                transcription: {\n                  type: Type.STRING,\n                  description: 'The deciphered ghostly phrase.'\n                },\n                confidence: {\n                  type: Type.NUMBER,\n                  description: 'The confidence score of the analysis.'\n                }\n              },\n              required: ['transcription', 'confidence']\n            },\n            temperature: 1.2\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getTemporalEcho() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Generate a \"temporal echo\" from a haunted location. This is a brief, one-paragraph description of a dramatic, tragic, or emotionally charged historical event that could leave a spiritual residue. Be vague about the exact location, but specific about the emotions and actions. Provide a title for the event and the historical era (e.g., 'Victorian', 'Prohibition', 'Colonial').`;\n        // Use proxy if available\n        if (_this5.proxyBaseUrl && _this5.proxyToken) {\n          const jwt = yield _this5.ensureProxyJwt();\n          const resp = yield fetch(`${_this5.proxyBaseUrl}/api/temporal-echo`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': `Bearer ${jwt}`\n            }\n          });\n          if (!resp.ok) throw new Error(`Proxy error: ${resp.status} ${yield resp.text()}`);\n          return yield resp.json();\n        }\n        _this5.ensureConfigured();\n        const response = yield _this5.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                title: {\n                  type: Type.STRING,\n                  description: 'The title of the historical event.'\n                },\n                era: {\n                  type: Type.STRING,\n                  description: 'The historical era of the event.'\n                },\n                description: {\n                  type: Type.STRING,\n                  description: 'The one-paragraph description of the echo.'\n                }\n              },\n              required: ['title', 'era', 'description']\n            },\n            temperature: 1.1\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    crossReferenceEntity(entity) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Cross-reference this paranormal entity against a global spectral database: Name: \"${entity.name}\", Type: \"${entity.type}\". Is there a known record? If so, provide a short, one-paragraph summary of its history or lore. If not, state that it's an undocumented anomaly. Respond in JSON format.`;\n        _this6.ensureConfigured();\n        const response = yield _this6.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                match: {\n                  type: Type.BOOLEAN\n                },\n                details: {\n                  type: Type.STRING\n                }\n              },\n              required: ['match', 'details']\n            }\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getEmotionalResonance(entity) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Analyze the backstory of the entity known as \"${entity.name}\" to determine its dominant emotional resonance. Backstory: \"${entity.backstory}\". List the top 3 emotions (e.g., Sorrow, Rage, Confusion) and a one-sentence summary of why. Respond in JSON format.`;\n        _this7.ensureConfigured();\n        const response = yield _this7.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                emotions: {\n                  type: Type.ARRAY,\n                  items: {\n                    type: Type.STRING\n                  }\n                },\n                summary: {\n                  type: Type.STRING\n                }\n              },\n              required: ['emotions', 'summary']\n            }\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getContainmentRitual(entity) {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        const prompt = `Generate a short, 2-step, procedural-sounding containment ritual for a paranormal entity named \"${entity.name}\" of type \"${entity.type}\". The steps should be cryptic and technical-sounding. Then provide a short, one-sentence outcome message confirming the successful containment. Respond in JSON format.`;\n        _this8.ensureConfigured();\n        const response = yield _this8.ai.models.generateContent({\n          model: 'gemini-2.5-flash',\n          contents: prompt,\n          config: {\n            responseMimeType: \"application/json\",\n            responseSchema: {\n              type: Type.OBJECT,\n              properties: {\n                steps: {\n                  type: Type.ARRAY,\n                  items: {\n                    type: Type.STRING\n                  }\n                },\n                outcome: {\n                  type: Type.STRING\n                }\n              },\n              required: ['steps', 'outcome']\n            },\n            temperature: 0.9\n          }\n        });\n        return JSON.parse(response.text.trim());\n      })();\n    }\n    getStrengthDescription(strength) {\n      switch (strength) {\n        case 'weak':\n          return 'faint and fleeting';\n        case 'moderate':\n          return 'clear and present';\n        case 'strong':\n          return 'powerful and disruptive';\n        case 'critical':\n          return 'overwhelming and physically manifesting';\n        default:\n          return 'of unknown power';\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function GeminiService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || GeminiService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: GeminiService,\n      factory: GeminiService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return GeminiService;\n})();","map":{"version":3,"names":["GoogleGenAI","Type","FALLBACK_GLYPH_B64","GeminiService","_staticBlock","constructor","proxyBaseUrl","proxyToken","proxyJwt","proxyJwtExpiresAt","key","process","env","API_KEY","apiKey","ai","console","warn","setApiKey","persist","Error","isProdHost","window","location","hostname","test","localStorage","setItem","setProxyConfig","baseUrl","token","replace","ensureProxyJwt","_this","_asyncToGenerator","now","Date","resp","fetch","method","headers","ok","status","text","body","json","parts","split","length","payload","JSON","parse","atob","exp","_","ensureConfigured","getEntityProfile","strength","_this2","jwt","stringify","strengthDescription","getStrengthDescription","profilePrompt","profileResponse","models","generateContent","model","contents","config","responseMimeType","responseSchema","type","OBJECT","properties","name","STRING","description","backstory","instability","NUMBER","contained","BOOLEAN","required","temperature","topP","jsonText","trim","profileData","glyphPrompt","imageResponse","generateImages","prompt","numberOfImages","outputMimeType","aspectRatio","glyphB64","generatedImages","image","imageBytes","analyzeScene","imageDataB64","_this3","imagePart","inlineData","mimeType","data","textPart","imageBase64","response","objects","ARRAY","items","polylines","x","y","getEVPMessage","_this4","transcription","confidence","getTemporalEcho","_this5","title","era","crossReferenceEntity","entity","_this6","match","details","getEmotionalResonance","_this7","emotions","summary","getContainmentRitual","_this8","steps","outcome","factory","ɵfac","providedIn"],"sources":["C:\\Users\\grand\\necrometer_-ghost-detector-1\\src\\services\\gemini.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { GoogleGenAI, Type } from \"@google/genai\";\r\nimport { EntityProfile, TemporalEcho, EVPAnalysis, DetectedEntity, CrossReferenceResult, EmotionalResonanceResult, ContainmentRitual, SceneAnalysisResult, SceneObject } from '../types';\r\n\r\n// A default fallback glyph in case image generation fails\r\nconst FALLBACK_GLYPH_B64 = 'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIrSURBVHhe7ZtNattAEID7/9+dFbSIIiJaNs06h5L2Wk2zJ5NCS80rFeLz4eG/4K+gKwhKBISKgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQISIgBARICISECEiQEQkIEJEgIhIQITw3wL8/vmx0+l0vV7/8Xg8Ho/HZDI5OTkRgZfL5XA4lMvl4+PjTqfT6XQ+n//1eDyZTAY4f2S5XF6v1/P5/Gaz+fPz89ls9vf3d7/f/08G2Gw2nU7n8/kymczn87e3t3e7XZ/P93q9brdbn8/3er0+n++3f/p/Axyfz/d6vW63W5/P93q9brfL5XKpVCoVCoXC4fD1+z/9ZwAul8vlcvl8vslk8ng8zWYz4P9I0+k0mUwul8vlcnk8Hm82m1KpFAqFw+Hw+vo6kP+Pfr+fTqdzOBwOh8PpdDgcDpVKhUKhUqlUKhUKhUqlUKhUKhUKhUqlUKhUKhUKhUqlUKhUKhUKhUqlUKhUKhUqlUKhUKhUKhUqlUKhUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUqlUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKhUKh8N8T/sFj4iwy+vRp2oAAAAASUVORK5CYII=';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class GeminiService {\r\n  private ai?: GoogleGenAI;\r\n  private apiKey?: string;\r\n  // Optional server-side proxy configuration\r\n  private proxyBaseUrl: string | null = null;\r\n  private proxyToken: string | null = null; // shared issuance token\r\n  private proxyJwt: string | null = null; // short-lived JWT obtained from /issue-token\r\n  private proxyJwtExpiresAt: number | null = null;\r\n\r\n  constructor() {\r\n    // Prefer server-side configuration. Do NOT automatically load an API key from browser storage.\r\n    // Server-side environment (Node) may provide an API key when running the server proxy.\r\n    let key: string | undefined;\r\n    try {\r\n      if (typeof process !== 'undefined' && (process as any).env && (process as any).env.API_KEY) {\r\n        key = (process as any).env.API_KEY;\r\n      }\r\n    } catch {}\r\n\r\n    if (key) {\r\n      this.apiKey = key;\r\n      this.ai = new GoogleGenAI({ apiKey: key });\r\n    } else {\r\n      // Not configured yet. Consumers must call setApiKey() (for dev) or configure proxy via setProxyConfig().\r\n      console.warn('GeminiService: API key not configured. Call setApiKey(apiKey) for development or setProxyConfig(baseUrl, token) to use the server proxy.');\r\n    }\r\n  }\r\n\r\n  /** Set API key at runtime (useful for web clients). This will instantiate the GoogleGenAI client. */\r\n  setApiKey(apiKey: string, persist = false) {\r\n    if (!apiKey || typeof apiKey !== 'string') throw new Error('Invalid API key');\r\n    // If running in a production-like environment (non-localhost), do not allow persistent client-side storage\r\n    const isProdHost = typeof window !== 'undefined' && window.location && window.location.hostname && !/^(localhost|127\\.0\\.0\\.1)$/.test(window.location.hostname);\r\n    if (persist && isProdHost) {\r\n      console.warn('Ignoring request to persist API key in production environment. Use the server-side proxy instead.');\r\n      persist = false;\r\n    }\r\n\r\n    this.apiKey = apiKey;\r\n    this.ai = new GoogleGenAI({ apiKey });\r\n\r\n    // Do not persist by default. Persist only when explicitly requested and not in production.\r\n    if (persist) {\r\n      try { localStorage.setItem('necrometer.apiKey', apiKey); } catch {}\r\n    }\r\n  }\r\n\r\n  /** Configure a server-side proxy (base URL) and shared bearer token. When configured, some requests will be routed through the proxy. */\r\n  setProxyConfig(baseUrl: string, token: string) {\r\n    this.proxyBaseUrl = baseUrl.replace(/\\/$/, '');\r\n    this.proxyToken = token;\r\n    // clear any cached JWT when proxy config changes\r\n    this.proxyJwt = null;\r\n    this.proxyJwtExpiresAt = null;\r\n  }\r\n\r\n  // Obtain a short-lived JWT from the proxy using the shared issuance token.\r\n  private async ensureProxyJwt(): Promise<string> {\r\n    if (!this.proxyBaseUrl || !this.proxyToken) throw new Error('Proxy not configured');\r\n    const now = Date.now();\r\n    if (this.proxyJwt && this.proxyJwtExpiresAt && now + 5000 < this.proxyJwtExpiresAt) {\r\n      return this.proxyJwt;\r\n    }\r\n    // Request a new JWT from the proxy issuance endpoint\r\n    const resp = await fetch(`${this.proxyBaseUrl}/issue-token`, {\r\n      method: 'POST',\r\n      headers: { 'Authorization': `Bearer ${this.proxyToken}` },\r\n    });\r\n    if (!resp.ok) {\r\n      throw new Error(`Failed to obtain proxy JWT: ${resp.status} ${await resp.text()}`);\r\n    }\r\n    const body = await resp.json();\r\n    const token = body && body.token;\r\n    if (!token) throw new Error('Proxy did not return a token');\r\n\r\n    // decode JWT expiry (simple parse of payload)\r\n    try {\r\n      const parts = token.split('.');\r\n      if (parts.length === 3) {\r\n        const payload = JSON.parse(atob(parts[1]));\r\n        if (payload && payload.exp) {\r\n          this.proxyJwtExpiresAt = payload.exp * 1000;\r\n        } else {\r\n          this.proxyJwtExpiresAt = Date.now() + 15 * 60 * 1000; // fallback 15m\r\n        }\r\n      }\r\n    } catch (_) {\r\n      this.proxyJwtExpiresAt = Date.now() + 15 * 60 * 1000;\r\n    }\r\n    this.proxyJwt = token;\r\n    return token;\r\n  }\r\n\r\n  private ensureConfigured() {\r\n    if (!this.ai && !(this.proxyBaseUrl && this.proxyToken)) {\r\n      throw new Error('GeminiService not configured: API key missing and proxy not configured. In production, configure the server proxy with setProxyConfig(baseUrl, token).');\r\n    }\r\n  }\r\n\r\n  async getEntityProfile(strength: 'weak' | 'moderate' | 'strong' | 'critical'): Promise<EntityProfile> {\r\n    // Use proxy endpoint if configured\r\n    if (this.proxyBaseUrl && this.proxyToken) {\r\n      const jwt = await this.ensureProxyJwt();\r\n      const resp = await fetch(`${this.proxyBaseUrl}/api/generate-entity-profile`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${jwt}` },\r\n        body: JSON.stringify({ strength }),\r\n      });\r\n      if (!resp.ok) throw new Error(`Proxy error: ${resp.status} ${await resp.text()}`);\r\n      return await resp.json() as EntityProfile;\r\n    }\r\n    this.ensureConfigured();\r\n    const strengthDescription = this.getStrengthDescription(strength);\r\n    const profilePrompt = `Generate a short, spooky, and mysterious profile for a paranormal entity. The energy signature is ${strengthDescription}. The profile must include a plausible name, a type (e.g., Poltergeist, Shade, Revenant, Wraith, Banshee, Phantom, Lingering Spirit), a one-paragraph backstory, and an 'instability' rating (a number from 50 to 100). The entity is not yet 'contained'. Do not use markdown.`;\r\n    // Call the real API and propagate errors to callers (no mocks returned here)\r\n    const profileResponse = await this.ai!.models.generateContent({\r\n      model: 'gemini-2.5-flash',\r\n      contents: profilePrompt,\r\n      config: {\r\n        responseMimeType: \"application/json\",\r\n        responseSchema: {\r\n          type: Type.OBJECT,\r\n          properties: {\r\n            name: { type: Type.STRING, description: 'The name of the entity.' },\r\n            type: { type: Type.STRING, description: 'The classification of the spirit.' },\r\n            backstory: { type: Type.STRING, description: 'A short, unsettling backstory.' },\r\n            instability: { type: Type.NUMBER, description: 'A rating from 50-100 of how unstable the entity is.'},\r\n            contained: { type: Type.BOOLEAN, description: 'Always false for new entities.'}\r\n          },\r\n          required: ['name', 'type', 'backstory', 'instability', 'contained'],\r\n        },\r\n        temperature: 1.1,\r\n        topP: 0.95,\r\n      },\r\n    });\r\n\r\n    const jsonText = profileResponse.text.trim();\r\n    const profileData = JSON.parse(jsonText) as Omit<EntityProfile, 'glyphB64'>;\r\n\r\n    // Now generate the glyph image based on the profile\r\n    const glyphPrompt = `Create a single, minimalist, arcane, mystical sigil or glyph that represents a paranormal entity. The entity is a \"${profileData.type}\" known as \"${profileData.name}\". The glyph should be a stark white design on a pure black background. It should look ancient and mysterious. It should not be a picture of the entity, but a symbolic representation.`;\r\n\r\n    const imageResponse = await this.ai!.models.generateImages({\r\n      model: 'imagen-3.0-generate-002',\r\n      prompt: glyphPrompt,\r\n      config: {\r\n        numberOfImages: 1,\r\n        outputMimeType: 'image/png',\r\n        aspectRatio: '1:1',\r\n      },\r\n    });\r\n    const glyphB64 = imageResponse.generatedImages[0].image.imageBytes;\r\n    return { ...profileData, glyphB64 };\r\n  }\r\n\r\n  async analyzeScene(imageDataB64: string): Promise<SceneAnalysisResult> {\r\n    const prompt = `Analyze this image from a first-person perspective. Identify up to 5 prominent objects or structures (like a door, chair, table, window). For each object, provide a simplified, stick-figure-like outline as an array of polylines. A polyline is an array of {x, y} points. Coordinates must be percentages (0-100) relative to the image dimensions. The outlines should be very simple and abstract. Respond in JSON format. If no objects are identifiable, return an empty 'objects' array.`;\r\n\r\n    const imagePart = {\r\n      inlineData: {\r\n        mimeType: 'image/jpeg',\r\n        data: imageDataB64,\r\n      },\r\n    };\r\n\r\n    const textPart = { text: prompt };\r\n\r\n    // Prefer proxy if configured\r\n    if (this.proxyBaseUrl && this.proxyToken) {\r\n      const jwt = await this.ensureProxyJwt();\r\n      const resp = await fetch(`${this.proxyBaseUrl}/api/analyze-scene`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${jwt}` },\r\n        body: JSON.stringify({ imageBase64: imageDataB64 }),\r\n      });\r\n      if (!resp.ok) throw new Error(`Proxy error: ${resp.status} ${await resp.text()}`);\r\n      return await resp.json() as SceneAnalysisResult;\r\n    }\r\n    this.ensureConfigured();\r\n    const response = await this.ai!.models.generateContent({\r\n      model: 'gemini-2.5-flash',\r\n      contents: { parts: [imagePart, textPart] },\r\n      config: {\r\n        responseMimeType: \"application/json\",\r\n        responseSchema: {\r\n          type: Type.OBJECT,\r\n          properties: {\r\n            objects: {\r\n              type: Type.ARRAY,\r\n              items: {\r\n                type: Type.OBJECT,\r\n                properties: {\r\n                  name: { type: Type.STRING },\r\n                  polylines: {\r\n                    type: Type.ARRAY,\r\n                    items: {\r\n                      type: Type.ARRAY,\r\n                      items: {\r\n                        type: Type.OBJECT,\r\n                        properties: {\r\n                          x: { type: Type.NUMBER },\r\n                          y: { type: Type.NUMBER }\r\n                        },\r\n                        required: ['x', 'y']\r\n                      }\r\n                    }\r\n                  }\r\n                },\r\n                required: ['name', 'polylines']\r\n              }\r\n            }\r\n          },\r\n          required: ['objects']\r\n        }\r\n      }\r\n    });\r\n    \r\n    return JSON.parse(response.text.trim()) as SceneAnalysisResult;\r\n  }\r\n\r\n  async getEVPMessage(): Promise<EVPAnalysis> {\r\n    const prompt = `I've captured Electronic Voice Phenomenon (EVP) audio static from a haunted location. From this static, invent a single, short, cryptic, and spooky phrase or sentence that sounds like it was whispered from another dimension. The phrase should be unsettling. Also provide a confidence score between 0.2 and 0.9.`;\r\n\r\n    this.ensureConfigured();\r\n    const response = await this.ai!.models.generateContent({\r\n        model: 'gemini-2.5-flash',\r\n        contents: prompt,\r\n        config: {\r\n          responseMimeType: \"application/json\",\r\n          responseSchema: {\r\n            type: Type.OBJECT,\r\n            properties: {\r\n              transcription: { type: Type.STRING, description: 'The deciphered ghostly phrase.' },\r\n              confidence: { type: Type.NUMBER, description: 'The confidence score of the analysis.' },\r\n            },\r\n            required: ['transcription', 'confidence'],\r\n          },\r\n          temperature: 1.2,\r\n        },\r\n    });\r\n\r\n    return JSON.parse(response.text.trim()) as EVPAnalysis;\r\n  }\r\n\r\n  async getTemporalEcho(): Promise<TemporalEcho> {\r\n    const prompt = `Generate a \"temporal echo\" from a haunted location. This is a brief, one-paragraph description of a dramatic, tragic, or emotionally charged historical event that could leave a spiritual residue. Be vague about the exact location, but specific about the emotions and actions. Provide a title for the event and the historical era (e.g., 'Victorian', 'Prohibition', 'Colonial').`;\r\n    // Use proxy if available\r\n    if (this.proxyBaseUrl && this.proxyToken) {\r\n      const jwt = await this.ensureProxyJwt();\r\n      const resp = await fetch(`${this.proxyBaseUrl}/api/temporal-echo`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${jwt}` },\r\n      });\r\n      if (!resp.ok) throw new Error(`Proxy error: ${resp.status} ${await resp.text()}`);\r\n      return await resp.json() as TemporalEcho;\r\n    }\r\n\r\n    this.ensureConfigured();\r\n    const response = await this.ai!.models.generateContent({\r\n       model: 'gemini-2.5-flash',\r\n       contents: prompt,\r\n       config: {\r\n         responseMimeType: \"application/json\",\r\n         responseSchema: {\r\n           type: Type.OBJECT,\r\n           properties: {\r\n             title: { type: Type.STRING, description: 'The title of the historical event.' },\r\n             era: { type: Type.STRING, description: 'The historical era of the event.' },\r\n             description: { type: Type.STRING, description: 'The one-paragraph description of the echo.' },\r\n           },\r\n           required: ['title', 'era', 'description'],\r\n         },\r\n         temperature: 1.1,\r\n       },\r\n    });\r\n\r\n    return JSON.parse(response.text.trim()) as TemporalEcho;\r\n  }\r\n  \r\n  async crossReferenceEntity(entity: DetectedEntity): Promise<CrossReferenceResult> {\r\n    const prompt = `Cross-reference this paranormal entity against a global spectral database: Name: \"${entity.name}\", Type: \"${entity.type}\". Is there a known record? If so, provide a short, one-paragraph summary of its history or lore. If not, state that it's an undocumented anomaly. Respond in JSON format.`;\r\n\r\n    this.ensureConfigured();\r\n    const response = await this.ai!.models.generateContent({\r\n        model: 'gemini-2.5-flash',\r\n        contents: prompt,\r\n        config: {\r\n          responseMimeType: \"application/json\",\r\n          responseSchema: {\r\n            type: Type.OBJECT,\r\n            properties: {\r\n              match: { type: Type.BOOLEAN },\r\n              details: { type: Type.STRING },\r\n            },\r\n            required: ['match', 'details'],\r\n          },\r\n        },\r\n    });\r\n    return JSON.parse(response.text.trim()) as CrossReferenceResult;\r\n  }\r\n\r\n  async getEmotionalResonance(entity: DetectedEntity): Promise<EmotionalResonanceResult> {\r\n    const prompt = `Analyze the backstory of the entity known as \"${entity.name}\" to determine its dominant emotional resonance. Backstory: \"${entity.backstory}\". List the top 3 emotions (e.g., Sorrow, Rage, Confusion) and a one-sentence summary of why. Respond in JSON format.`;\r\n\r\n     this.ensureConfigured();\r\n     const response = await this.ai!.models.generateContent({\r\n        model: 'gemini-2.5-flash',\r\n        contents: prompt,\r\n        config: {\r\n          responseMimeType: \"application/json\",\r\n          responseSchema: {\r\n            type: Type.OBJECT,\r\n            properties: {\r\n              emotions: { type: Type.ARRAY, items: { type: Type.STRING } },\r\n              summary: { type: Type.STRING },\r\n            },\r\n            required: ['emotions', 'summary'],\r\n          },\r\n        },\r\n    });\r\n    return JSON.parse(response.text.trim()) as EmotionalResonanceResult;\r\n  }\r\n\r\n  async getContainmentRitual(entity: DetectedEntity): Promise<ContainmentRitual> {\r\n    const prompt = `Generate a short, 2-step, procedural-sounding containment ritual for a paranormal entity named \"${entity.name}\" of type \"${entity.type}\". The steps should be cryptic and technical-sounding. Then provide a short, one-sentence outcome message confirming the successful containment. Respond in JSON format.`;\r\n\r\n    this.ensureConfigured();\r\n    const response = await this.ai!.models.generateContent({\r\n        model: 'gemini-2.5-flash',\r\n        contents: prompt,\r\n        config: {\r\n          responseMimeType: \"application/json\",\r\n          responseSchema: {\r\n            type: Type.OBJECT,\r\n            properties: {\r\n              steps: { type: Type.ARRAY, items: { type: Type.STRING } },\r\n              outcome: { type: Type.STRING },\r\n            },\r\n            required: ['steps', 'outcome'],\r\n          },\r\n          temperature: 0.9,\r\n        },\r\n    });\r\n    return JSON.parse(response.text.trim()) as ContainmentRitual;\r\n  }\r\n\r\n\r\n  private getStrengthDescription(strength: string): string {\r\n    switch (strength) {\r\n      case 'weak': return 'faint and fleeting';\r\n      case 'moderate': return 'clear and present';\r\n      case 'strong': return 'powerful and disruptive';\r\n      case 'critical': return 'overwhelming and physically manifesting';\r\n      default: return 'of unknown power';\r\n    }\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}