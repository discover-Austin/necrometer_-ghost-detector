{"ast":null,"code":"export function pointInPolygon(point, polygon) {\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x,\n      yi = polygon[i].y;\n    const xj = polygon[j].x,\n      yj = polygon[j].y;\n    const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi + 1e-12) + xi;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\nexport function findNearestAnchor(sceneObjects, spawnX, spawnY) {\n  let best = null;\n  let bestDist = Infinity;\n  for (let oi = 0; oi < sceneObjects.length; oi++) {\n    const obj = sceneObjects[oi];\n    for (let pi = 0; pi < obj.polylines.length; pi++) {\n      const poly = obj.polylines[pi];\n      for (let pt = 0; pt < poly.length; pt++) {\n        const p = poly[pt];\n        const dx = spawnX - p.x;\n        const dy = spawnY - p.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist < bestDist) {\n          bestDist = dist;\n          best = {\n            objectIndex: oi,\n            polylineIndex: pi,\n            pointIndex: pt,\n            baseX: p.x,\n            baseY: p.y\n          };\n        }\n      }\n    }\n  }\n  if (!best) return null;\n  // Add a deterministic depth based on objectIndex to vary anchors predictably\n  best.offsetX = spawnX - best.baseX;\n  best.offsetY = spawnY - best.baseY;\n  best.depth = 1 + best.objectIndex % 3 * 0.45; // 1.0,1.45,1.9 repeatable\n  return best;\n}\nexport function computeOcclusionLevel(entity, sceneObjects) {\n  if (!entity.anchor) return 0;\n  const a = entity.anchor;\n  const obj = sceneObjects[a.objectIndex];\n  if (!obj) return 0;\n  for (const poly of obj.polylines) {\n    if (poly && poly.length >= 3) {\n      if (pointInPolygon({\n        x: a.baseX + a.offsetX,\n        y: a.baseY + a.offsetY\n      }, poly)) {\n        // occlusion scales with depth: depth <=1 => 0; depth 1..2 => 0..1\n        const depth = a.depth || 1;\n        return Math.max(0, Math.min(1, (depth - 1) / 1.0));\n      }\n    }\n  }\n  return 0;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}